msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-18 20:31+0200\n"
"PO-Revision-Date: 2020-12-10 18:01+0800\n"
"Last-Translator: taotieren <admin@taotieren.com>\n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.1\n"
"X-Poedit-Basepath: .\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Poedit-SourceCharset: UTF-8\n"

#: ../../source/iconview.txt:2
msgid "IconView"
msgstr "图标视图"

#: ../../source/iconview.txt:3
msgid ""
"A :class:`Gtk.IconView` is a widget that displays a collection of icons in a "
"grid view. It supports features such as drag and drop, multiple selections "
"and item reordering."
msgstr ""
"A :class:`Gtk.IconView` 是一个在网格视图中显示一组图标的小部件。它支持拖放、"
"多选和项目重新排序等功能。"

#: ../../source/iconview.txt:5
msgid ""
"Similarly to :class:`Gtk.TreeView`, :class:`Gtk.IconView` uses a :class:`Gtk."
"ListStore` for its model. Instead of using :ref:`cell renderers "
"<cellrenderers>`, :class:`Gtk.IconView` requires that one of the columns in "
"its :class:`Gtk.ListStore` contains :class:`GdkPixbuf.Pixbuf` objects."
msgstr ""
"与 :class:`Gtk.TreeView`，:class:`Gtk.IconView` 使用 :class:`Gtk.ListStore` "
"作为其模型。而不是使用:ref:`cell renderers <cellrenderers>`，:class:`Gtk."
"IconView` 要求其 :class:`Gtk.ListStore` 中的一列包含 :class:`GdkPixbuf."
"Pixbuf` 对象。"

#: ../../source/iconview.txt:7
msgid ""
":class:`Gtk.IconView` supports numerous selection modes to allow for either "
"selecting multiple icons at a time, restricting selections to just one item "
"or disallowing selecting items completely. To specify a selection mode, the :"
"meth:`Gtk.IconView.set_selection_mode` method is used with one of the :class:"
"`Gtk.SelectionMode` selection modes."
msgstr ""
":class:`Gtk.IconView` 支持多种选择模式，允许一次选择多个图标，将选择限制为仅"
"一个项目，或完全不允许选择项目。为了指定选择模式，:meth:`Gtk.IconView."
"set_selection_mode` 方法与 :class:`Gtk.SelectionMode` 选择模式之一一一起使"
"用。"

#: ../../source/iconview.txt:10 ../../source/layout.txt:40
#: ../../source/layout.txt:97 ../../source/layout.txt:123
#: ../../source/layout.txt:156 ../../source/layout.txt:180
#: ../../source/layout.txt:212 ../../source/layout.txt:232
#: ../../source/button_widgets.txt:18 ../../source/button_widgets.txt:39
#: ../../source/button_widgets.txt:78 ../../source/button_widgets.txt:95
#: ../../source/button_widgets.txt:131 ../../source/button_widgets.txt:150
#: ../../source/spinner.txt:12 ../../source/spinner.txt:29
#: ../../source/layout-table.txt:26 ../../source/combobox.txt:29
#: ../../source/builder.txt:118 ../../source/entry.txt:32
#: ../../source/clipboard.txt:17 ../../source/cellrenderers.txt:39
#: ../../source/cellrenderers.txt:59 ../../source/cellrenderers.txt:74
#: ../../source/cellrenderers.txt:98 ../../source/cellrenderers.txt:116
#: ../../source/cellrenderers.txt:138 ../../source/menus.txt:80
#: ../../source/textview.txt:115 ../../source/label.txt:48
#: ../../source/dialogs.txt:46 ../../source/dialogs.txt:66
#: ../../source/dialogs.txt:130 ../../source/popover.txt:19
#: ../../source/popover.txt:34 ../../source/drag_and_drop.txt:74
#: ../../source/application.txt:61 ../../source/progressbar.txt:32
msgid "Example"
msgstr "示例"

#: ../../source/layout.txt:4
msgid "Layout Containers"
msgstr "布局容器"

#: ../../source/layout.txt:5
msgid ""
"While many GUI toolkits require you to precisely place widgets in a window, "
"using absolute positioning, GTK+ uses a different approach. Rather than "
"specifying the position and size of each widget in the window, you can "
"arrange your widgets in rows, columns, and/or tables. The size of your "
"window can be determined automatically, based on the sizes of the widgets it "
"contains. And the sizes of the widgets are, in turn, determined by the "
"amount of text they contain, or the minimum and maximum sizes that you "
"specify, and/or how you have requested that the available space should be "
"shared between sets of widgets. You can perfect your layout by specifying "
"padding distance and centering values for each of your widgets. GTK+ then "
"uses all this information to resize and reposition everything sensibly and "
"smoothly when the user manipulates the window."
msgstr ""
"虽然许多 GUI 工具包要求您使用绝对定位将部件精确放置到窗口中，但 GTK+ 使用不同"
"的方法。您可以按行、列和/或表排列部件，而不是指定窗口中每个部件的位置和大小。"
"可以根据窗口包含的部件的大小自动确定窗口的大小。部件的大小又由它们包含的文本"
"量、您指定的最小大小和最大大小和/或请求在部件库之间共享可用空间的方面决定。您"
"可以通过为每个部件指定填充距离和居中值来完善布局。然后，GTK+ 使用所有这些信息"
"来调整大小，并在用户操作窗口时合理而顺利地重新定位所有内容。"

#: ../../source/layout.txt:19
msgid ""
"GTK+ arranges widgets hierarchically, using *containers*. They are invisible "
"to the end user and are inserted into a window, or placed within each other "
"to layout components. There are two flavours of containers: single-child "
"containers, which are all descendants of :class:`Gtk.Bin`, and multiple-"
"child containers, which are descendants of :class:`Gtk.Container`. The most "
"commonly used are vertical or horizontal boxes (:class:`Gtk.Box`) and grids "
"(:class:`Gtk.Grid`)."
msgstr ""
"GTK+ 使用 *容器* 分层排列部件。它们对最终用户不可见，并插入到窗口中，或彼此内"
"放置到布局组件中。容器有两种口味：单子容器，它们都是 :class:`Gtk.Bin` 的继"
"承，多子容器是 :class:`Gtk.Container` 的继承。最常用的是垂直或水平框（:class:"
"`Gtk.Box`）和网格（:class:`Gtk.Grid`）。"

#: ../../source/layout.txt:29
msgid "Boxes"
msgstr "框"

#: ../../source/layout.txt:31
msgid ""
"Boxes are invisible containers into which we can pack our widgets. When "
"packing widgets into a horizontal box, the objects are inserted horizontally "
"from left to right or right to left depending on whether :meth:`Gtk.Box."
"pack_start` or :meth:`Gtk.Box.pack_end` is used. In a vertical box, widgets "
"are packed from top to bottom or vice versa. You may use any combination of "
"boxes inside or beside other boxes to create the desired effect."
msgstr ""
"框是看不见的容器，我们可以把部件装进盒子里。将部件打包到水平框中时，根据使用"
"的是 :meth:`Gtk.Box.pack_start` 还是 :meth:`Gtk.Box.pack_end`，对象将从左向右"
"或从右向左水平插入。在垂直方框中，部件从上到下打包，反之亦然。您可以使用其他"
"框内部或旁边的框的任意组合来创建所需的效果。"

#: ../../source/layout.txt:42
#, fuzzy
msgid ""
"Let's take a look at a slightly modified version of the extended example "
"with two buttons."
msgstr "让我们来看看带有两个按钮的扩展示例的稍微修改的版本。"

#: ../../source/layout.txt:50
#, fuzzy
msgid ""
"First, we create a horizontally orientated box container where 6 pixels are "
"placed between children. This box becomes the child of the top-level window."
msgstr ""
"首先，我们创建一个水平定向的框容器，其中 6 个像素放置在子容器之间。此框将成为"
"顶层窗口的子窗口。"

#: ../../source/layout.txt:56
#, fuzzy
msgid "Subsequently, we add two different buttons to the box container."
msgstr "随后，我们将两个不同的按钮添加到框容器中。"

#: ../../source/layout.txt:61
#, fuzzy
msgid ""
"While with :meth:`Gtk.Box.pack_start` widgets are positioned from left to "
"right, :meth:`Gtk.Box.pack_end` positions them from right to left."
msgstr ""
"而与 ：meth：'Gtk.Box.pack_start'小部件定位从左到右，：Gtk.Box.pack_end'位置"
"他们从左到右。"

#: ../../source/layout.txt:67
msgid "Grid"
msgstr "网格"

#: ../../source/layout.txt:68
#, fuzzy
msgid ""
":class:`Gtk.Grid` is a container which arranges its child widgets in rows "
"and columns, but you do not need to specify the dimensions in the "
"constructor. Children are added using :meth:`Gtk.Grid.attach`. They can span "
"multiple rows or columns. The :meth:`Gtk.Grid.attach` method takes five "
"parameters:"
msgstr ""
"：类：\"Gtk.Grid\"是一个容器，它将其子小部件排列在行和列中，但不需要在构造函"
"数中指定维度。儿童添加使用 ：meth：'Gtk.Grid.attach'。它们可以跨越多行或多"
"列。：meth：'Gtk.Grid.attach' 方法采用五个参数："

#: ../../source/layout.txt:73
#, fuzzy
msgid "The ``child`` parameter is the :class:`Gtk.Widget` to add."
msgstr "\"子\"参数是 ：class：'Gtk.Widget\"添加。"

#: ../../source/layout.txt:74
#, fuzzy
msgid "``left`` is the column number to attach the left side of ``child`` to."
msgstr "\"左\"是将\"子\"左侧附加到的列号。"

#: ../../source/layout.txt:75
#, fuzzy
msgid ""
"``top`` indicates the row number to attach the top side of ``child`` to."
msgstr "\"top\"表示要将\"子\"的顶端附加到的行号。"

#: ../../source/layout.txt:76
#, fuzzy
msgid ""
"``width`` and ``height`` indicate the number of columns that the ``child`` "
"will span, and the number of rows that the ``child`` will span, respectively."
msgstr "\"宽度\"和\"高度\"分别指示\"子\"将跨越的列数，以及\"子\"将跨越的行数。"

#: ../../source/layout.txt:79
#, fuzzy
msgid ""
"It is also possible to add a child next to an existing child, using :meth:"
"`Gtk.Grid.attach_next_to`, which also takes five parameters:"
msgstr "也可以使用 ：meth：'Gtk.Grid.attach_next_to\"在现有子项旁边添加子级："

#: ../../source/layout.txt:82
#, fuzzy
msgid "``child`` is the :class:`Gtk.Widget` to add, as above."
msgstr "\"孩子\"是 ：class：'Gtk.Widget'要添加，如上所述。"

#: ../../source/layout.txt:83
#, fuzzy
msgid ""
"``sibling`` is an existing child widget of ``self`` (a :class:`Gtk.Grid` "
"instance) or ``None``. The ``child`` widget will be placed next to "
"``sibling``, or if ``sibling`` is ``None``, at the beginning or end of the "
"grid."
msgstr ""
"\"兄弟姐妹\"是\"自我\"（a：class：'Gtk.Grid'实例）或\"无\"的现有子小部"
"件。\"孩子\"小部件将放置在\"兄弟姐妹\"旁边，或者如果\"同级\"是\"无\"，则位于"
"网格的开头或末尾。"

#: ../../source/layout.txt:86
#, fuzzy
msgid ""
"``side`` is a :class:`Gtk.PositionType` indicating the side of ``sibling`` "
"that ``child`` is positioned next to."
msgstr ""
"\"侧\"是 ：class：'Gtk.位置类型'，指示\"同级\"的一侧，即\"孩子\"位于旁边。"

#: ../../source/layout.txt:88
#, fuzzy
msgid ""
"``width`` and ``height`` indicate the number of columns and rows the "
"``child`` widget will span, respectively."
msgstr "\"宽度\"和\"高度\"分别指示\"子\"小部件将跨越的列数和行数。"

#: ../../source/layout.txt:91
#, fuzzy
msgid ""
"Finally, :class:`Gtk.Grid` can be used like a :class:`Gtk.Box` by just "
"using :meth:`Gtk.Grid.add`, which will place children next to each other in "
"the direction determined by the \"orientation\" property (defaults to :attr:"
"`Gtk.Orientation.HORIZONTAL`)."
msgstr ""
"最后，：类：'Gtk.Grid'可以像：类：'Gtk.Box'一样使用，只需使用：meth：'Gtk."
"Grid.add'，它将子级彼此放在由\"方向\"属性确定的方向（默认为 ：attr：'Gtk."
"Orientation.水平'）。"

#: ../../source/layout.txt:105
msgid "ListBox"
msgstr "列表框"

#: ../../source/layout.txt:107
#, fuzzy
msgid ""
"A :class:`Gtk.ListBox` is a vertical container that contains :class:`Gtk."
"ListBoxRow` children. These rows can be dynamically sorted and filtered, and "
"headers can be added dynamically depending on the row content. It also "
"allows keyboard and mouse navigation and selection like a typical list."
msgstr ""
"A ：class：'Gtk.listBox' 是一个垂直容器，其中包含 ：class：'Gtk.listBoxRow' "
"子级。这些行可以动态排序和筛选，并且可以根据行内容动态添加标头。它还允许键盘"
"和鼠标导航和选择像一个典型的列表。"

#: ../../source/layout.txt:112
#, fuzzy
msgid ""
"Using :class:`Gtk.ListBox` is often an alternative to :class:`Gtk.TreeView`, "
"especially when the list content has a more complicated layout than what is "
"allowed by a :class:`Gtk.CellRenderer`, or when the content is interactive "
"(i.e. has a button in it)."
msgstr ""
"使用 ：class：'Gtk.ListBox' 通常是 ：class：'Gtk.TreeView'的替代方法，特别是"
"当列表内容的布局比 ：class：'Gtk.CellRenderer'允许的布局更为复杂时，或者当内"
"容是交互式的（即包含一个按钮时）。"

#: ../../source/layout.txt:117
#, fuzzy
msgid ""
"Although a :class:`Gtk.ListBox` must have only :class:`Gtk.ListBoxRow` "
"children, you can add any kind of widget to it via :meth:`Gtk.Container.add` "
"and a :class:`Gtk.ListBoxRow` widget will automatically be inserted between "
"the list and the widget."
msgstr ""
"虽然 ：class：'Gtk.listBox' 必须只有：类：'Gtk.listBoxRow' 子级，但您可以通"
"过：meth：'Gtk.容器.add'和 ：class：'Gtk.listBoxRow'小部件自动插入列表和小部"
"件之间，向其添加任何类型的小部件。"

#: ../../source/layout.txt:131
msgid "Stack and StackSwitcher"
msgstr "堆栈和堆栈切换器"

#: ../../source/layout.txt:133
#, fuzzy
msgid ""
"A :class:`Gtk.Stack` is a container which only shows one of its children at "
"a time. In contrast to :class:`Gtk.Notebook`, :class:`Gtk.Stack` does not "
"provide a means for users to change the visible child. Instead, the :class:"
"`Gtk.StackSwitcher` widget can be used with :class:`Gtk.Stack` to provide "
"this functionality."
msgstr ""
"A ：class：'Gtk.Stack' 是一个容器，一次只显示其一个子级。与 ：class：'Gtk."
"Notebook'，：类：'Gtk.Stack'相比，不为用户提供更改可见子级的手段。相反，："
"class：'Gtk.StackSwitcher' 小部件可以与 ：class：'Gtk.Stack'一起使用，以提供"
"此功能。"

#: ../../source/layout.txt:139
#, fuzzy
msgid ""
"Transitions between pages can be animated as slides or fades. This can be "
"controlled with :meth:`Gtk.Stack.set_transition_type`. These animations "
"respect the \"gtk-enable-animations\" setting."
msgstr ""
"页面之间的过渡可以作为幻灯片或淡入淡出进行动画处理。这可以通过：冰毒：'Gtk."
"Stack.set_transition_type'。这些动画尊重\"gtk 启用动画\"设置。"

#: ../../source/layout.txt:143
#, fuzzy
msgid ""
"Transition speed can be adjusted with :meth:`Gtk.Stack."
"set_transition_duration`"
msgstr "过渡速度可以调整为：冰毒：'Gtk.Stack.set_transition_duration'"

#: ../../source/layout.txt:145
#, fuzzy
msgid ""
"The :class:`Gtk.StackSwitcher` widget acts as a controller for a :class:`Gtk."
"Stack`; it shows a row of buttons to switch between the various pages of the "
"associated stack widget."
msgstr ""
"：类：'Gtk.StackSwitcher' 小部件充当 ：class 的控制器：'Gtk.Stack';它显示一排"
"按钮，用于在关联堆栈小部件的各个页面之间切换。"

#: ../../source/layout.txt:149
#, fuzzy
msgid ""
"All the content for the buttons comes from the child properties of the :"
"class:`Gtk.Stack`."
msgstr "按钮的所有内容都来自 ：class 的子属性：'Gtk.Stack'。"

#: ../../source/layout.txt:152
#, fuzzy
msgid ""
"It is possible to associate multiple :class:`Gtk.StackSwitcher` widgets with "
"the same :class:`Gtk.Stack` widget."
msgstr ""
"可以关联多个 ：class：'Gtk.StackSwitcher'小部件与相同的 ：class：'Gtk."
"Stack'小部件。"

#: ../../source/layout.txt:164
msgid "HeaderBar"
msgstr "标题栏"

#: ../../source/layout.txt:166
#, fuzzy
msgid ""
"A :class:`Gtk.HeaderBar` is similar to a horizontal :class:`Gtk.Box`, it "
"allows to place children at the start or the end. In addition, it allows a "
"title to be displayed. The title will be centered with respect to the width "
"of the box, even if the children at either side take up different amounts of "
"space."
msgstr ""
"A ：class：'Gtk.headerBar' 类似于水平 ：class：'Gtk.Box'，它允许在开始或结束"
"放置子级。此外，它允许显示标题。标题将围绕框的宽度居中，即使两侧的子体占用不"
"同量的空间。"

#: ../../source/layout.txt:171
#, fuzzy
msgid ""
"Since GTK+ now supports Client Side Decoration, a :class:`Gtk.HeaderBar` can "
"be used in place of the title bar (which is rendered by the Window Manager)."
msgstr ""
"由于 GTK+ 现在支持客户端装饰，因此可以使用 ：class：'Gtk.TitleBar' 代替标题栏"
"（由窗口管理器呈现）。"

#: ../../source/layout.txt:174
#, fuzzy
msgid ""
"A :class:`Gtk.HeaderBar` is usually located across the top of a window and "
"should contain commonly used controls which affect the content below. They "
"also provide access to window controls, including the close window button "
"and window menu."
msgstr ""
"A ：class：'Gtk.HeaderBar' 通常位于窗口顶部，应包含影响以下内容的常用控件。它"
"们还提供对窗口控件的访问，包括关闭窗口按钮和窗口菜单。"

#: ../../source/layout.txt:188
msgid "FlowBox"
msgstr "流盒"

#: ../../source/layout.txt:190
msgid "This example requires at least GTK+ 3.12."
msgstr "此示例至少需要 GTK+ 3.12。"

#: ../../source/layout.txt:192
#, fuzzy
msgid ""
"A :class:`Gtk.FlowBox` is a container that positions child widgets in "
"sequence according to its orientation."
msgstr ""
"a ：class：'Gtk.FlowBox' 是一个容器，它根据子小部件的方向按顺序定位子小部件。"

#: ../../source/layout.txt:195
#, fuzzy
msgid ""
"For instance, with the horizontal orientation, the widgets will be arranged "
"from left to right, starting a new row under the previous row when "
"necessary. Reducing the width in this case will require more rows, so a "
"larger height will be requested."
msgstr ""
"例如，使用水平方向时，小部件将从左到右排列，必要时在上一行下开始新行。在这种"
"情况下，减小宽度将需要更多的行，因此将请求更大的高度。"

#: ../../source/layout.txt:200
#, fuzzy
msgid ""
"Likewise, with the vertical orientation, the widgets will be arranged from "
"top to bottom, starting a new column to the right when necessary. Reducing "
"the height will require more columns, so a larger width will be requested."
msgstr ""
"同样，使用垂直方向时，小部件将从上到下排列，必要时从右侧开始新列。降低高度将"
"需要更多的列，因此将请求更大的宽度。"

#: ../../source/layout.txt:204
#, fuzzy
msgid ""
"The children of a :class:`Gtk.FlowBox` can be dynamically sorted and "
"filtered."
msgstr "：类的子级：'Gtk.FlowBox'可以动态排序和筛选。"

#: ../../source/layout.txt:206
#, fuzzy
msgid ""
"Although a :class:`Gtk.FlowBox` must have only :class:`Gtk.FlowBoxChild` "
"children, you can add any kind of widget to it via :meth:`Gtk.Container."
"add`, and a :class:`Gtk.FlowBoxChild` widget will automatically be inserted "
"between the box and the widget."
msgstr ""
"虽然 ：class：'Gtk.FlowBox' 必须只有：类：'Gtk.FlowBoxChild'子级，但您可以通"
"过：meth：'Gtk.容器.add'向其添加任何类型的小部件，并且 ：class：'Gtk."
"FlowBoxChild' 小部件将自动插入框和小部件之间。"

#: ../../source/layout.txt:220
msgid "Notebook"
msgstr "笔记本"

#: ../../source/layout.txt:222
#, fuzzy
msgid ""
"The :class:`Gtk.Notebook` widget is a :class:`Gtk.Container` whose children "
"are pages that can be switched between using tab labels along one edge."
msgstr ""
"：class：'Gtk.Notebook' 小部件是 ：class：'Gtk.容器'，其子级是可以在沿一条边"
"使用选项卡标签之间切换的页面。"

#: ../../source/layout.txt:224
#, fuzzy
msgid ""
"There are many configuration options for GtkNotebook. Among other things, "
"you can choose on which edge the tabs appear (see :meth:`Gtk.Notebook."
"set_tab_pos`), whether, if there are too many tabs to fit the notebook "
"should be made bigger or scrolling arrows added (see :meth:`Gtk.Notebook."
"set_scrollable`, and whether there will be a popup menu allowing the users "
"to switch pages (see :meth:`Gtk.Notebook.popup_enable`, :meth:`Gtk.Notebook."
"popup_disable`)."
msgstr ""
"GtkNotebook 有许多配置选项。除其他事项外，您可以选择选项卡出现在哪个边（请参"
"阅：meth：'Gtk.Notebook.set_tab_pos'）、是否，如果有太多的选项卡适合笔记本，"
"是否应使笔记本变大或添加滚动箭头（请参阅：meth：'Gtk.Notebook."
"set_scrollable'，以及是否有允许用户切换页面的弹出式菜单（请参阅：meth：'Gtk."
"Notebook.popup_enable'，：meth：'Gtk.Notebook.popup_disable'）。"

#: ../../source/gallery.txt:2
msgid "Widget Gallery"
msgstr "部件库"

#: ../../source/gallery.txt:5
msgid ":class:`Gtk.AboutDialog`"
msgstr ":class:`Gtk.AboutDialog`"

#: ../../source/gallery.txt:6
msgid ":class:`Gtk.AccelLabel`"
msgstr ":class:`Gtk.AccelLabel`"

#: ../../source/gallery.txt:7
msgid ":class:`Gtk.ActionBar`"
msgstr ":class:`Gtk.ActionBar`"

#: ../../source/gallery.txt:8
msgid ":class:`Gtk.AppChooserButton`"
msgstr ":class:`Gtk.AppChooserButton`"

#: ../../source/gallery.txt:9
msgid ":class:`Gtk.AppChooserDialog`"
msgstr ":class:`Gtk.AppChooserDialog`"

#: ../../source/gallery.txt:10
msgid ":class:`Gtk.Assistant`"
msgstr ":class:`Gtk.Assistant`"

#: ../../source/gallery.txt:11
msgid ":class:`Gtk.Button`"
msgstr ":class:`Gtk.Button`"

#: ../../source/gallery.txt:12
msgid ":class:`Gtk.CheckButton`"
msgstr ":class:`Gtk.CheckButton`"

#: ../../source/gallery.txt:13
msgid ":class:`Gtk.ColorButton`"
msgstr ":class:`Gtk.ColorButton`"

#: ../../source/gallery.txt:14
msgid ":class:`Gtk.ColorChooserDialog`"
msgstr ":class:`Gtk.ColorChooserDialog`"

#: ../../source/gallery.txt:15
msgid ":class:`Gtk.ComboBox`"
msgstr ":class:`Gtk.ComboBox`"

#: ../../source/gallery.txt:16
msgid ":class:`Gtk.ComboBoxText`"
msgstr ":class:`Gtk.ComboBoxText`"

#: ../../source/gallery.txt:17
msgid ":class:`Gtk.Entry`"
msgstr ":class:`Gtk.Entry`"

#: ../../source/gallery.txt:18
msgid ":class:`Gtk.FileChooserButton`"
msgstr ":class:`Gtk.FileChooserButton`"

#: ../../source/gallery.txt:19
msgid ":class:`Gtk.FileChooserDialog`"
msgstr ":class:`Gtk.FileChooserDialog`"

#: ../../source/gallery.txt:20
msgid ":class:`Gtk.FlowBox`"
msgstr ":class:`Gtk.FlowBox`"

#: ../../source/gallery.txt:21
msgid ":class:`Gtk.FontButton`"
msgstr ":class:`Gtk.FontButton`"

#: ../../source/gallery.txt:22
msgid ":class:`Gtk.FontChooserDialog`"
msgstr ":class:`Gtk.FontChooserDialog`"

#: ../../source/gallery.txt:23
msgid ":class:`Gtk.Frame`"
msgstr ":class:`Gtk.Frame`"

#: ../../source/gallery.txt:24
msgid ":class:`Gtk.GLArea`"
msgstr ":class:`Gtk.GLArea`"

#: ../../source/gallery.txt:25
msgid ":class:`Gtk.Grid`"
msgstr ":class:`Gtk.Grid`"

#: ../../source/gallery.txt:26
msgid ":class:`Gtk.HeaderBar`"
msgstr ":class:`Gtk.HeaderBar`"

#: ../../source/gallery.txt:27
msgid ":class:`Gtk.IconView`"
msgstr ":class:`Gtk.IconView`"

#: ../../source/gallery.txt:28
msgid ":class:`Gtk.Image`"
msgstr ":class:`Gtk.Image`"

#: ../../source/gallery.txt:29
msgid ":class:`Gtk.InfoBar`"
msgstr ":class:`Gtk.InfoBar`"

#: ../../source/gallery.txt:30
msgid ":class:`Gtk.Label`"
msgstr ":class:`Gtk.Label`"

#: ../../source/gallery.txt:31
msgid ":class:`Gtk.LevelBar`"
msgstr ":class:`Gtk.LevelBar`"

#: ../../source/gallery.txt:32
msgid ":class:`Gtk.LinkButton`"
msgstr ":class:`Gtk.LinkButton`"

#: ../../source/gallery.txt:33
msgid ":class:`Gtk.ListBox`"
msgstr ":class:`Gtk.ListBox`"

#: ../../source/gallery.txt:34
msgid ":class:`Gtk.LockButton`"
msgstr ":class:`Gtk.LockButton`"

#: ../../source/gallery.txt:35
msgid ":class:`Gtk.MenuBar`"
msgstr ":class:`Gtk.MenuBar`"

#: ../../source/gallery.txt:36
msgid ":class:`Gtk.MenuButton`"
msgstr ":class:`Gtk.MenuButton`"

#: ../../source/gallery.txt:37
msgid ":class:`Gtk.MessageDialog`"
msgstr ":class:`Gtk.MessageDialog`"

#: ../../source/gallery.txt:38
msgid ":class:`Gtk.Notebook`"
msgstr ":class:`Gtk.Notebook`"

#: ../../source/gallery.txt:39
msgid ":class:`Gtk.Paned`"
msgstr ":class:`Gtk.Paned`"

#: ../../source/gallery.txt:40
msgid ":class:`Gtk.PlacesSidebar`"
msgstr ":class:`Gtk.PlacesSidebar`"

#: ../../source/gallery.txt:41
msgid ":class:`Gtk.ProgressBar`"
msgstr ":class:`Gtk.ProgressBar`"

#: ../../source/gallery.txt:42
msgid ":class:`Gtk.RadioButton`"
msgstr ":class:`Gtk.RadioButton`"

#: ../../source/gallery.txt:43
msgid ":class:`Gtk.RecentChooserDialog`"
msgstr ":class:`Gtk.RecentChooserDialog`"

#: ../../source/gallery.txt:44
msgid ":class:`Gtk.Scale`"
msgstr ":class:`Gtk.Scale`"

#: ../../source/gallery.txt:45
msgid ":class:`Gtk.Scrollbar`"
msgstr ":class:`Gtk.Scrollbar`"

#: ../../source/gallery.txt:46
msgid ":class:`Gtk.ScrolledWindow`"
msgstr ":class:`Gtk.ScrolledWindow`"

#: ../../source/gallery.txt:47
msgid ":class:`Gtk.SearchBar`"
msgstr ":class:`Gtk.SearchBar`"

#: ../../source/gallery.txt:48
msgid ":class:`Gtk.SearchEntry`"
msgstr ":class:`Gtk.SearchEntry`"

#: ../../source/gallery.txt:49
msgid ":class:`Gtk.Separator`"
msgstr ":class:`Gtk.Separator`"

#: ../../source/gallery.txt:50
msgid ":class:`Gtk.SpinButton`"
msgstr ":class:`Gtk.SpinButton`"

#: ../../source/gallery.txt:51
msgid ":class:`Gtk.Spinner`"
msgstr ":class:`Gtk.Spinner`"

#: ../../source/gallery.txt:52
msgid ":class:`Gtk.Stack`"
msgstr ":class:`Gtk.Stack`"

#: ../../source/gallery.txt:53
msgid ":class:`Gtk.StackSwitcher`"
msgstr ":class:`Gtk.StackSwitcher`"

#: ../../source/gallery.txt:54
msgid ":class:`Gtk.Statusbar`"
msgstr ":class:`Gtk.Statusbar`"

#: ../../source/gallery.txt:55
msgid ":class:`Gtk.Switch`"
msgstr ":class:`Gtk.Switch`"

#: ../../source/gallery.txt:56
msgid ":class:`Gtk.TextView`"
msgstr ":class:`Gtk.TextView`"

#: ../../source/gallery.txt:57
msgid ":class:`Gtk.ToggleButton`"
msgstr ":class:`Gtk.ToggleButton`"

#: ../../source/gallery.txt:58
msgid ":class:`Gtk.ToolPalette`"
msgstr ":class:`Gtk.ToolPalette`"

#: ../../source/gallery.txt:59
msgid ":class:`Gtk.Toolbar`"
msgstr ":class:`Gtk.Toolbar`"

#: ../../source/gallery.txt:60
msgid ":class:`Gtk.TreeView`"
msgstr ":class:`Gtk.TreeView`"

#: ../../source/gallery.txt:61
msgid ":class:`Gtk.VolumeButton`"
msgstr ":class:`Gtk.VolumeButton`"

#: ../../source/gallery.txt:62
msgid ":class:`Gtk.Window`"
msgstr ":class:`Gtk.Window`"

#: ../../source/button_widgets.txt:2
msgid "Button Widgets"
msgstr "按钮部件"

#: ../../source/button_widgets.txt:5
msgid "Button"
msgstr "按钮"

#: ../../source/button_widgets.txt:7
#, fuzzy
msgid ""
"The Button widget is another commonly used widget. It is generally used to "
"attach a function that is called when the button is pressed."
msgstr "按钮小部件是另一个常用的小部件。它通常用于附加按下按钮时调用的函数。"

#: ../../source/button_widgets.txt:10
#, fuzzy
msgid ""
"The :class:`Gtk.Button` widget can hold any valid child widget. That is it "
"can hold most any other standard :class:`Gtk.Widget`. The most commonly used "
"child is the :class:`Gtk.Label`."
msgstr ""
"：class：'Gtk.button' 小部件可以容纳任何有效的子小部件。这是它可以容纳大多数"
"任何其他标准：类：'Gtk.Widget'。最常用的子级是 ：class：'Gtk.Label'。"

#: ../../source/button_widgets.txt:14
#, fuzzy
msgid ""
"Usually, you want to connect to the button's \"clicked\" signal which is "
"emitted when the button has been pressed and released."
msgstr "通常，您希望连接到按钮的\"单击\"信号，该信号在按下并释放按钮时发出。"

#: ../../source/button_widgets.txt:26
msgid "ToggleButton"
msgstr "切换按钮"

#: ../../source/button_widgets.txt:28
#, fuzzy
msgid ""
"A :class:`Gtk.ToggleButton` is very similar to a normal :class:`Gtk.Button`, "
"but when clicked they remain activated, or pressed, until clicked again. "
"When the state of the button is changed, the \"toggled\" signal is emitted."
msgstr ""
"A ：class：'Gtk.toggleButton' 与普通 ：class：'Gtk.Button'非常相似，但单击"
"时，它们将保持激活或按下状态，直到再次单击。当按钮的状态更改时，将发出\"切换"
"\"信号。"

#: ../../source/button_widgets.txt:32
#, fuzzy
msgid ""
"To retrieve the state of the :class:`Gtk.ToggleButton`, you can use the :"
"meth:`Gtk.ToggleButton.get_active` method. This returns ``True`` if the "
"button is \"down\". You can also set the toggle button's state, with :meth:"
"`Gtk.ToggleButton.set_active`. Note that, if you do this, and the state "
"actually changes, it causes the \"toggled\" signal to be emitted."
msgstr ""
"要检索 ：class：'Gtk.toggleButton'的状态，可以使用 ：meth：'Gtk.ToggleButton."
"get_active方法。如果按钮\"关闭\"，这将返回\"True\"。您也可以设置切换按钮的状"
"态，使用 ：meth：'Gtk.ToggleButton.set_active'。请注意，如果这样做，并且状态"
"实际上更改，则会导致发出\"切换\"信号。"

#: ../../source/button_widgets.txt:47
msgid "CheckButton"
msgstr "检查按钮"

#: ../../source/button_widgets.txt:48
#, fuzzy
msgid ""
":class:`Gtk.CheckButton` inherits from :class:`Gtk.ToggleButton`. The only "
"real difference between the two is :class:`Gtk.CheckButton`'s appearance. A :"
"class:`Gtk.CheckButton` places a discrete :class:`Gtk.ToggleButton` next to "
"a widget, (usually a :class:`Gtk.Label`). The \"toggled\" signal, :meth:`Gtk."
"ToggleButton.set_active` and :meth:`Gtk.ToggleButton.get_active` are "
"inherited."
msgstr ""
"：类：'Gtk.CheckButton'继承自：类：'Gtk.toggleButton'。两者之间唯一的真正区别"
"是 ：class：'Gtk.CheckButton 的外观。A ：class：'Gtk.CheckButton'将一个离散"
"的：类：'Gtk.toggleButton'位于小部件旁边（通常是 ：class：'Gtk.Label'）。\"切"
"换\"信号：冰毒：'Gtk.ToggleButton.set_active'和：Gtk.ToggleButton."
"get_active'是继承的。"

#: ../../source/button_widgets.txt:56
msgid "RadioButton"
msgstr "单选按钮"

#: ../../source/button_widgets.txt:57
#, fuzzy
msgid ""
"Like checkboxes, radio buttons also inherit from :class:`Gtk.ToggleButton`, "
"but these work in groups, and only one :class:`Gtk.RadioButton` in a group "
"can be selected at any one time. Therefore, a :class:`Gtk.RadioButton` is "
"one way of giving the user a choice from many options."
msgstr ""
"与复选框一样，单选按钮也继承自 ：class：'Gtk.toggleButton'，但这些按钮在组中"
"工作，组中只能选择一个：类：'Gtk.RadioButton'。因此，a 类：'Gtk.RadioButton' "
"是允许用户从许多选项中进行选择的一种方式。"

#: ../../source/button_widgets.txt:62
#, fuzzy
msgid ""
"Radio buttons can be created with one of the static methods :meth:`Gtk."
"RadioButton.new_from_widget`, :meth:`Gtk.RadioButton."
"new_with_label_from_widget` or :meth:`Gtk.RadioButton."
"new_with_mnemonic_from_widget`. The first radio button in a group will be "
"created passing ``None`` as the *group* argument. In subsequent calls, the "
"group you wish to add this button to should be passed as an argument."
msgstr ""
"单选按钮可以使用静态方法之一创建：Gtk.RadioButton.new_from_widget：'Gtk."
"RadioButton.new_with_mnemonic_from_widget Gtk.RadioButton."
"new_with_label_from_widget'。组中的第一个单选按钮将创建传递\"无\"作为 *组* 参"
"数。在后续调用中，要将此按钮添加到的组应作为参数传递。"

#: ../../source/button_widgets.txt:70
#, fuzzy
msgid ""
"When first run, the first radio button in the group will be active. This can "
"be changed by calling :meth:`Gtk.ToggleButton.set_active` with ``True`` as "
"first argument."
msgstr ""
"第一次运行时，组中的第一个单选按钮将处于活动状态。这可以通过调用 ："
"meth：'Gtk.ToggleButton.set_active'和'True'作为第一个参数来改变。"

#: ../../source/button_widgets.txt:74
#, fuzzy
msgid ""
"Changing a :class:`Gtk.RadioButton`'s widget group after its creation can be "
"achieved by calling :meth:`Gtk.RadioButton.join_group`."
msgstr ""
"更改 ：class：'Gtk.RadioButton 的小部件组创建后可以通过调用 ：meth：'Gtk."
"RadioButton.join_group\" 实现的。"

#: ../../source/button_widgets.txt:86
msgid "LinkButton"
msgstr "链接按钮"

#: ../../source/button_widgets.txt:87
#, fuzzy
msgid ""
"A :class:`Gtk.LinkButton` is a :class:`Gtk.Button` with a hyperlink, similar "
"to the one used by web browsers, which triggers an action when clicked. It "
"is useful to show quick links to resources."
msgstr ""
"A ：class：'Gtk.LinkButton' 是一个 ：class：'Gtk.Button'，具有超链接，类似于 "
"Web 浏览器使用的超链接，在单击时触发操作。显示指向资源的快速链接很有用。"

#: ../../source/button_widgets.txt:91
#, fuzzy
msgid ""
"The URI bound to a :class:`Gtk.LinkButton` can be set specifically using :"
"meth:`Gtk.LinkButton.set_uri`, and retrieved using :meth:`Gtk.LinkButton."
"get_uri`."
msgstr ""
"绑定到 ：class 的 URI：'Gtk.LinkButton' 可以专门使用 ：meth：'Gtk.LinkButton."
"set_uri'进行设置，并使用 ：meth：'Gtk.LinkButton.get_uri\"进行检索。"

#: ../../source/button_widgets.txt:103
msgid "SpinButton"
msgstr "旋转按钮"

#: ../../source/button_widgets.txt:104
#, fuzzy
msgid ""
"A :class:`Gtk.SpinButton` is an ideal way to allow the user to set the value "
"of some attribute. Rather than having to directly type a number into a :"
"class:`Gtk.Entry`, :class:`Gtk.SpinButton` allows the user to click on one "
"of two arrows to increment or decrement the displayed value. A value can "
"still be typed in, with the bonus that it can be checked to ensure it is in "
"a given range. The main properties of a :class:`Gtk.SpinButton` are set "
"through :class:`Gtk.Adjustment`."
msgstr ""
"A ：class：'Gtk.SpinButton' 是允许用户设置某些属性值的理想方法。不必直接在 ："
"class：'Gtk.Entry'中键入数字：'Gtk.Entry'，：类：'Gtk.SpinButton'允许用户单击"
"两个箭头之一来递增或递增显示的值。仍可以键入值，并检查其奖金以确保其位于给定"
"范围内。：class：'Gtk.SpinButton'的主要属性通过 ：class：'Gtk.调整'进行设置。"

#: ../../source/button_widgets.txt:112
#, fuzzy
msgid ""
"To change the value that :class:`Gtk.SpinButton` is showing, use :meth:`Gtk."
"SpinButton.set_value`. The value entered can either be an integer or float, "
"depending on your requirements, use :meth:`Gtk.SpinButton.get_value` or :"
"meth:`Gtk.SpinButton.get_value_as_int`, respectively."
msgstr ""
"要更改 ：class：'Gtk.SpinButton'显示的值，请使用 ：meth：'Gtk.SpinButton."
"set_value\"。输入的值可以是整数值，也可以是浮点数，具体取决于您的要求，分别使"
"用 ：meth：'Gtk.SpinButton.get_value'或：meth：'Gtk.SpinButton."
"get_value_as_int'。"

#: ../../source/button_widgets.txt:117
#, fuzzy
msgid ""
"When you allow the displaying of float values in the spin button, you may "
"wish to adjust the number of decimal spaces displayed by calling :meth:`Gtk."
"SpinButton.set_digits`."
msgstr ""
"当允许在旋转按钮中显示浮点值时，您可能希望通过调用 ：meth：'Gtk.SpinButton."
"set_digits\"来调整小数位数。"

#: ../../source/button_widgets.txt:121
#, fuzzy
msgid ""
"By default, :class:`Gtk.SpinButton` accepts textual data. If you wish to "
"limit this to numerical values only, call :meth:`Gtk.SpinButton.set_numeric` "
"with ``True`` as argument."
msgstr ""
"默认情况下，：类：'Gtk.SpinButton'接受文本数据。如果希望仅将此值限制为数值，"
"请调用 ：meth：Gtk.SpinButton.set_numeric\"true\"作为参数。"

#: ../../source/button_widgets.txt:125
#, fuzzy
msgid ""
"We can also adjust the update policy of :class:`Gtk.SpinButton`. There are "
"two options here; by default the spin button updates the value even if the "
"data entered is invalid. Alternatively, we can set the policy to only update "
"when the value entered is valid by calling :meth:`Gtk.SpinButton."
"set_update_policy`."
msgstr ""
"我们还可以调整 ：class：'Gtk.SpinButton'的更新策略。这里有两个选项;默认情况"
"下，即使输入的数据无效，旋转按钮也更新该值。或者，我们可以将策略设置为仅在输"
"入的值有效时通过调用 ：meth：'Gtk.SpinButton.set_update_policy。"

#: ../../source/button_widgets.txt:139
msgid "Switch"
msgstr "开关"

#: ../../source/button_widgets.txt:140
#, fuzzy
msgid ""
"A :class:`Gtk.Switch` is a widget that has two states: on or off. The user "
"can control which state should be active by clicking the empty area, or by "
"dragging the handle."
msgstr ""
"A ：class：'Gtk.switch' 是具有两种状态的小部件：开或关。用户可以通过单击空区"
"域或拖动句柄来控制哪个状态应处于活动状态。"

#: ../../source/button_widgets.txt:144
#, fuzzy
msgid ""
"You shouldn't use the \"activate\" signal on the Gtk.Switch which is an "
"action signal and emitting it causes the switch to animate. Applications "
"should never connect to this signal, but use the \"notify::active\" signal, "
"see the example here below."
msgstr ""
"您不应在 Gtk.switch 上使用 \"激活\" 信号， 这是一个动作信号， 并发出它会导致"
"开关成为动画。应用程序不应连接到此信号，但使用\"通知：：活动\"信号，请参阅下"
"面的示例。"

#: ../../source/index.txt:7
msgid "The Python GTK+ 3 Tutorial"
msgstr "Python GTK+ 3 教程"

#: ../../source/index.txt:0
msgid "Release"
msgstr "发布"

#: ../../source/index.txt:9
msgid "|version|"
msgstr "| 版本 |"

#: ../../source/index.txt:0
msgid "Date"
msgstr "日期"

#: ../../source/index.txt:10
msgid "|today|"
msgstr "| 今天 |"

#: ../../source/index.txt:0
msgid "Copyright"
msgstr "版权"

#: ../../source/index.txt:11
#, fuzzy
msgid ""
"GNU Free Documentation License 1.3 with no Invariant Sections, no Front-"
"Cover Texts, and no Back-Cover Texts"
msgstr "GNU 免费文档许可证 1.3，无不变部分，无前盖文本，无后盖文本"

#: ../../source/index.txt:13
#, fuzzy
msgid ""
"This tutorial gives an introduction to writing GTK+ 3 applications in Python."
msgstr "本教程介绍了在 Python 中编写 GTK+ 3 应用程序。"

#: ../../source/index.txt:15
#, fuzzy
msgid ""
"Prior to working through this tutorial, it is recommended that you have a "
"reasonable grasp of the Python programming language. GUI programming "
"introduces new problems compared to interacting with the standard output "
"(console / terminal). It is necessary for you to know how to create and run "
"Python files, understand basic interpreter errors, and work with strings, "
"integers, floats and Boolean values. For the more advanced widgets in this "
"tutorial, good knowledge of lists and tuples will be needed."
msgstr ""
"在完成本教程之前，建议您合理掌握 Python 编程语言。与与标准输出（控制台/终端）"
"交互相比，GUI 编程引入了新问题。您必须知道如何创建和运行 Python 文件，了解基"
"本解释器错误，以及使用字符串、整数、浮点和布尔值。对于本教程中更高级的小部"
"件，需要了解列表和元组。"

#: ../../source/index.txt:25
#, fuzzy
msgid ""
"Although this tutorial describes the most important classes and methods "
"within GTK+ 3, it is not supposed to serve as an API reference. Please refer "
"to the `GTK+ 3 Reference Manual <https://developer.gnome.org/gtk3/stable/>`_ "
"for a detailed description of the API. Also there's a `Python-specific "
"reference <https://lazka.github.io/pgi-docs/>`_ available."
msgstr ""
"尽管本教程介绍了 GTK+ 3 中最重要的类和方法，但它不应用作 API 引用。有关 API "
"的详细说明，请参阅\"GTK+ 3 参考手册< https：//开发人员.gnome.org/gtk3/稳定/>"
"\"_。此外，还有一个\"Python特定的引用<https：//lazka.github.io/pgi-docs/>\"_ "
"_ 可用。"

#: ../../source/index.txt:31
msgid "Contents:"
msgstr "目录："

#: ../../source/index.txt:61
msgid "Deprecated"
msgstr "弃用"

#: ../../source/index.txt:69
msgid "Indices and tables"
msgstr "索引和表格"

#: ../../source/index.txt:71
msgid ":ref:`search`"
msgstr ":ref:`search`"

#: ../../source/spinner.txt:2
msgid "Spinner"
msgstr "微调"

#: ../../source/spinner.txt:4
#, fuzzy
msgid ""
"The :class:`Gtk.Spinner` displays an icon-size spinning animation. It is "
"often used as an alternative to a :class:`GtkProgressBar` for displaying "
"indefinite activity, instead of actual progress."
msgstr ""
"：class：'Gtk.Spinner' 显示图标大小的旋转动画。它通常用作 ：class 的替代方"
"法：'Gtk 进步栏'，用于显示不确定活动，而不是实际进度。"

#: ../../source/spinner.txt:8
#, fuzzy
msgid ""
"To start the animation, use :meth:`Gtk.Spinner.start`, to stop it use :meth:"
"`Gtk.Spinner.stop`."
msgstr ""
"要开始动画，请使用 ：meth：'Gtk.Spinner.start'，停止使用：meth：'Gtk.Spinner."
"stop'。"

#: ../../source/spinner.txt:20
msgid "Extended example"
msgstr "扩展示例"

#: ../../source/spinner.txt:22
#, fuzzy
msgid ""
"An extended example that uses a timeout function to start and stop the "
"spinning animation. The :func:`on_timeout` function is called at regular "
"intervals until it returns ``False``, at which point the timeout is "
"automatically destroyed and the function will not be called again."
msgstr ""
"使用超时函数启动和停止旋转动画的扩展示例。：func：'on_timeout'函数定期调用，"
"直到它返回\"False\"，此时超时将自动销毁，并且不会再次调用该函数。"

#: ../../source/layout-table.txt:2
msgid "Table"
msgstr "表格"

#: ../../source/layout-table.txt:4
#, fuzzy
msgid ""
":class:`Gtk.Table` has been deprecated since GTK+ version 3.4 and should not "
"be used in newly-written code. Use the :ref:`layout-grid` class instead."
msgstr ""
"：类：\"Gtk.Table\"自 GTK® 版本 3.4 以来已弃用，不应在新编写的代码中使用。请"
"改为使用 ：ref：'布局网格'类。"

#: ../../source/layout-table.txt:8
#, fuzzy
msgid ""
"Tables allows us to place widgets in a grid similar to :class:`Gtk.Grid`."
msgstr "表允许我们将小部件放在类似于 ：class：'Gtk.Grid'的网格中。"

#: ../../source/layout-table.txt:10
#, fuzzy
msgid ""
"The grid's dimensions need to be specified in the :class:`Gtk.Table` "
"constructor. To place a widget into a box, use :meth:`Gtk.Table.attach`."
msgstr ""
"网格的维度需要在 ：class：'Gtk.Table' 构造函数中指定。要将小部件放入框中，请"
"使用 ：meth：'Gtk.Table.attach'。"

#: ../../source/layout-table.txt:13
#, fuzzy
msgid ""
":meth:`Gtk.Table.set_row_spacing` and :meth:`Gtk.Table.set_col_spacing` set "
"the spacing between the rows at the specified row or column. Note that for "
"columns, the space goes to the right of the column, and for rows, the space "
"goes below the row."
msgstr ""
"：meth：Gtk.Table.set_row_spacing'和 ：Gtk.Table.set_col_spacing：'设置指定行"
"或列的行之间的间距。请注意，对于列，空格将转到列的右侧;对于行，空格将转到行下"
"方。"

#: ../../source/layout-table.txt:18
#, fuzzy
msgid ""
"You can also set a consistent spacing for all rows and/or columns with :meth:"
"`Gtk.Table.set_row_spacings` and :meth:`Gtk.Table.set_col_spacings`. Note "
"that with these calls, the last row and last column do not get any spacing."
msgstr ""
"您还可以设置所有行和/或列的一致间距，使用 ：meth：'Gtk.Table."
"set_row_spacings'和：meth：'Gtk.Table.set_col_spacings\"。请注意，对于这些调"
"用，最后一行和最后一列不会获得任何间距。"

#: ../../source/layout-table.txt:22
#, fuzzy
msgid "It is reccomened that you use the :class:`Gtk.Grid` for new code."
msgstr "重新计算了使用 ：class：'Gtk.Grid' 的新代码。"

#: ../../source/combobox.txt:2
msgid "ComboBox"
msgstr "组合框"

#: ../../source/combobox.txt:3
#, fuzzy
msgid ""
"A :class:`Gtk.ComboBox` allows for the selection of an item from a dropdown "
"menu. They are preferable to having many radio buttons on screen as they "
"take up less room. If appropriate, it can show extra information about each "
"item, such as text, a picture, a checkbox, or a progress bar."
msgstr ""
"A ：class：'Gtk.ComboBox' 允许从下拉菜单中选择项目。他们比在屏幕上有许多单选"
"按钮更可取，因为它们的空间更少。如果合适，它可以显示有关每个项目的额外信息，"
"如文本、图片、复选框或进度条。"

#: ../../source/combobox.txt:8
#, fuzzy
msgid ""
":class:`Gtk.ComboBox` is very similar to :class:`Gtk.TreeView`, as both use "
"the model-view pattern; the list of valid choices is specified in the form "
"of a tree model, and the display of the choices can be adapted to the data "
"in the model by using :ref:`cell renderers <cellrenderers>`. If the combo "
"box contains a large number of items, it may be better to display them in a "
"grid rather than a list. This can be done by calling :meth:`Gtk.ComboBox."
"set_wrap_width`."
msgstr ""
"：类：\"Gtk.ComboBox\"与 ：class 非常相似：'Gtk.TreeView'，因为两者都使用模型"
"视图模式;有效选项列表以树模型的形式指定，可以使用 ：ref：'单元格渲染器）将选"
"项的显示调整为模型中 <cellrenderers>的数据。如果组合框包含大量项，则最好在网"
"格中显示它们，而不是在列表中显示它们。这可以通过调用：meth：'Gtk.ComboBox."
"set_wrap_width\" 。</cellrenderers>"

#: ../../source/combobox.txt:16
#, fuzzy
msgid ""
"The :class:`Gtk.ComboBox` widget usually restricts the user to the available "
"choices, but it can optionally have an :class:`Gtk.Entry`, allowing the user "
"to enter arbitrary text if none of the available choices are suitable. To do "
"this, use one of the static methods :meth:`Gtk.ComboBox.new_with_entry` or :"
"meth:`Gtk.ComboBox.new_with_model_and_entry` to create an :class:`Gtk."
"ComboBox` instance."
msgstr ""
"：class：'Gtk.ComboBox' 小部件通常将用户限制为可用选项，但它可以选择 ："
"class：'Gtk.Entry'，允许用户在没有任何可用选项适合时输入任意文本。为此，请使"
"用静态方法之一：Gtk.ComboBox.new_with_entry：'Gtk.ComboBox."
"new_with_entry'或：Gtk.ComboBox.new_with_model_and_entry'创建一个："
"class：'Gtk.ComboBox'实例。"

#: ../../source/combobox.txt:23
#, fuzzy
msgid ""
"For a simple list of textual choices, the model-view API of :class:`Gtk."
"ComboBox` can be a bit overwhelming. In this case, :class:`Gtk.ComboBoxText` "
"offers a simple alternative. Both :class:`Gtk.ComboBox` and :class:`Gtk."
"ComboBoxText` can contain an entry."
msgstr ""
"对于文本选择的简单列表，：class 的模型视图 API：'Gtk.ComboBox'可能有点让人不"
"知所措。在这种情况下，：类：'Gtk.ComboBoxText'提供了一个简单的替代方案。两个 "
"：class：'Gtk.ComboBox' 和 ：class：'Gtk.ComboBoxText'都可以包含一个条目。"

#: ../../source/unicode.txt:2
msgid "How to Deal With Strings"
msgstr "如何处理字符串"

#: ../../source/unicode.txt:4
#, fuzzy
msgid ""
"This section explains how strings are represented in Python 2.x, Python 3.x "
"and GTK+ and discusses common errors that arise when working with strings."
msgstr ""
"本节介绍 Python 2.x、Python 3.x 和 GTK® 中字符串的表示方式，并讨论使用字符串"
"时出现的常见错误。"

#: ../../source/unicode.txt:8
msgid "Definitions"
msgstr "定义"

#: ../../source/unicode.txt:9
#, fuzzy
msgid ""
"Conceptually, a string is a list of characters such as 'A', 'B', 'C' or 'É'. "
"**Characters** are abstract representations and their meaning depends on the "
"language and context they are used in. The Unicode standard describes how "
"characters are represented by **code points**. For example the characters "
"above are represented with the code points U+0041, U+0042, U+0043, and U"
"+00C9, respectively. Basically, code points are numbers in the range from 0 "
"to 0x10FFFF."
msgstr ""
"从概念上讲，字符串是字符列表，如\"A\"，\"B\"，\"C\"或\"+\"。**字符**是抽象的"
"表示形式，其含义取决于它们所使用的语言和上下文。Unicode 标准描述字符如何由 **"
"代码点**表示。例如，上面的字符分别用代码点 U=0041、U=0042、U=0043 和 U=00C9 "
"表示。基本上，代码点是 0 到 0x10FF 范围内的数字。"

#: ../../source/unicode.txt:17
#, fuzzy
msgid ""
"As mentioned earlier, the representation of a string as a list of code "
"points is abstract. In order to convert this abstract representation into a "
"sequence of bytes, the Unicode string must be **encoded**. The simplest form "
"of encoding is ASCII and is performed as follows:"
msgstr ""
"如前所述，字符串作为代码点列表的表示形式是抽象的。为了将此抽象表示形式转换为"
"字节序列，必须**编码Unicode字符串**。最简单的编码形式是 ASCII，执行方式如下："

#: ../../source/unicode.txt:22
#, fuzzy
msgid ""
"If the code point is < 128, each byte is the same as the value of the code "
"point."
msgstr "如果代码点< 128，则每个字节与代码点的值相同。"

#: ../../source/unicode.txt:25
#, fuzzy
msgid ""
"If the code point is 128 or greater, the Unicode string can't be represented "
"in this encoding.  (Python raises a :exc:`UnicodeEncodeError` exception in "
"this case.)"
msgstr ""
"如果代码点为 128 或更高，则无法在此编码中表示 Unicode 字符串。 （在这种情况"
"下，Python 将引发 ：exc：\"Unicodeerror\"异常。"

#: ../../source/unicode.txt:29
#, fuzzy
msgid ""
"Although ASCII encoding is simple to apply it can only encode for 128 "
"different characters which is hardly enough. One of the most commonly used "
"encodings that addresses this problem is UTF-8 (it can handle any Unicode "
"code point). UTF stands for \"Unicode Transformation Format\", and the '8' "
"means that 8-bit numbers are used in the encoding."
msgstr ""
"虽然 ASCII 编码是简单的应用，它只能编码 128 个不同的字符，这是远远不够的。解"
"决此问题最常用的编码之一是 UTF-8（它可以处理任何 Unicode 代码点）。UTF 代表"
"\"统一代码转换格式\"，而\"8\"表示编码中使用 8 位数字。"

#: ../../source/unicode.txt:37
msgid "Python 2"
msgstr "Python 2"

#: ../../source/unicode.txt:40
msgid "Python 2.x’s Unicode Support"
msgstr "Python 2.x 的 Unicode 支持"

#: ../../source/unicode.txt:41
#, fuzzy
msgid ""
"Python 2 comes with two different kinds of objects that can be used to "
"represent strings, :class:`str` and :class:`unicode`. Instances of the "
"latter are used to express Unicode strings, whereas instances of the :class:"
"`str` type are byte representations (the encoded string). Under the hood, "
"Python represents Unicode strings as either 16- or 32-bit integers, "
"depending on how the Python interpreter was compiled. Unicode strings can be "
"converted to 8-bit strings with :meth:`unicode.encode`::"
msgstr ""
"Python 2 附带两种不同类型的对象，可用于表示字符串，：类：'str' 和 ："
"class：'unicode'。后者的实例用于表示 Unicode 字符串，而 ：class：'str' 类型的"
"实例是字节表示形式（编码的字符串）。在引擎盖下，Python 将 Unicode 字符串表示"
"为 16 位或 32 位整数，具体取决于 Python 解释器的编译方法。Unicode 字符串可以"
"转换为 8 位字符串，使用 ：meth：'unicode.encode'："

#: ../../source/unicode.txt:58
#, fuzzy
msgid ""
"Python’s 8-bit strings have a :meth:`str.decode` method that interprets the "
"string using the given encoding::"
msgstr ""
"Python 的 8 位字符串具有 ：meth：'str.decode' 方法，使用给定的编码解释字符"
"串：："

#: ../../source/unicode.txt:68
#, fuzzy
msgid ""
"Unfortunately, Python 2.x allows you to mix :class:`unicode` and :class:"
"`str` if the 8-bit string happened to contain only 7-bit (ASCII) bytes, but "
"would get :exc:`UnicodeDecodeError` if it contained non-ASCII values::"
msgstr ""
"不幸的是，Python 2.x 允许您混合 ：class：'unicode' 和 ：class：如果 8 位字符"
"串碰巧只包含 7 位 （ASCII） 字节，但如果包含非 ASCI 值，则会得到："
"exc：'Unicodedecodeerror'：："

#: ../../source/unicode.txt:85 ../../source/unicode.txt:148
msgid "Unicode in GTK+"
msgstr "GTK+ 中的 Unicode"

#: ../../source/unicode.txt:86
#, fuzzy
msgid ""
"GTK+ uses UTF-8 encoded strings for all text. This means that if you call a "
"method that returns a string you will always obtain an instance of the :"
"class:`str` type. The same applies to methods that expect one or more "
"strings as parameter, they must be UTF-8 encoded. However, for convenience "
"PyGObject will automatically convert any :class:`unicode` instance to :class:"
"`str` if supplied as argument::"
msgstr ""
"GTK+ 使用 UTF-8 编码字符串的所有文本。这意味着，如果调用返回字符串的方法，则"
"始终获取 ：class：'str' 类型的实例。这同样适用于需要一个或多个字符串作为参数"
"的方法，它们必须是 UTF-8 编码的。但是，为了方便起见，PyGObject 将自动将任何 "
"：class：'unicode' 实例转换为：class：'str'（如果作为参数提供：："

#: ../../source/unicode.txt:104
#, fuzzy
msgid ""
"Note the warning at the end. Although we called :meth:`Gtk.Label.set_text` "
"with a :class:`unicode` instance as argument, :meth:`Gtk.Label.get_text` "
"will always return a :class:`str` instance. Accordingly, ``txt`` and "
"``unicode_string`` are *not* equal."
msgstr ""
"请注意末尾的警告。虽然我们用 ：class：'Gtk.Label.set_text：'unicode'实例作为"
"参数，：meth：'Gtk.Label.get_text'将始终返回 ：class：'str'实例。因此，\"txt"
"\"和\"unicode_string\"是*不相等的。"

#: ../../source/unicode.txt:109
#, fuzzy
msgid ""
"This is especially important if you want to internationalize your program "
"using `gettext <https://docs.python.org/3/library/gettext.html>`_. You have "
"to make sure that gettext will return UTF-8 encoded 8-bit strings for all "
"languages. In general it is recommended to not use :class:`unicode` objects "
"in GTK+ applications at all and only use UTF-8 encoded :class:`str` objects "
"since GTK+ does not fully integrate with :class:`unicode` objects. "
"Otherwise, you would have to decode the return values to Unicode strings "
"each time you call a GTK+ method::"
msgstr ""
"如果您要使用\"gettext<https：//docs.python.org/3/库/gettext.html>\"来使程序国"
"际化，这一点尤其重要。您必须确保所有语言的 gettext 将返回 UTF-8 编码的 8 位字"
"符串。通常建议在 GTK® 应用程序中不使用 ：class：'unicode' 对象，并且只使用 "
"UTF-8 编码 ：class：'str' 对象，因为 GTK+ 未完全与 ：class：'unicode'对象完全"
"集成。否则，每次调用 GTK+ 方法时，必须将返回值解码为 Unicode 字符串：："

#: ../../source/unicode.txt:122
msgid "Python 3"
msgstr "Python 3"

#: ../../source/unicode.txt:125
msgid "Python 3.x's Unicode support"
msgstr "Python 3.x 的 Unicode 支持"

#: ../../source/unicode.txt:126
#, fuzzy
msgid ""
"Since Python 3.0, all strings are stored as Unicode in an instance of the :"
"class:`str` type. *Encoded* strings on the other hand are represented as "
"binary data in the form of instances of the :class:`bytes` type. "
"Conceptually, :class:`str` refers to *text*, whereas :class:`bytes` refers "
"to *data*. Use :meth:`str.encode` to go from :class:`str` to :class:`bytes`, "
"and :meth:`bytes.decode` to go from :class:`bytes` to :class:`str`."
msgstr ""
"自 Python 3.0 以来，所有字符串都存储为 Unicode 在 ：class：'str' 类型的实例"
"中。*另一方面，编码* 字符串以 ：class：'字节'类型的实例的形式表示为二进制数"
"据。从概念上讲，：：'str'是指*文本*，而：类：'字节'是指*数据*。使用 ："
"meth：'str.encode' 从 ：class：'str' 到 ：class：'字节'，和：meth：'字节.解"
"码'从 ：class：'字节'转到 ：类：'str'。"

#: ../../source/unicode.txt:133
#, fuzzy
msgid ""
"In addition, it is no longer possible to mix Unicode strings with encoded "
"strings, because it will result in a :exc:`TypeError`::"
msgstr ""
"此外，不再可能将 Unicode 字符串与编码字符串混合，因为它将导致 ："
"exc：'TypeError'：："

#: ../../source/unicode.txt:149
#, fuzzy
msgid ""
"As a consequence, things are much cleaner and consistent with Python 3.x, "
"because PyGObject will automatically encode/decode to/from UTF-8 if you pass "
"a string to a method or a method returns a string. Strings, or *text*, will "
"always be represented as instances of :class:`str` only::"
msgstr ""
"因此，事情更简洁，与 Python 3.x 一致，因为如果将字符串传递给方法或方法返回字"
"符串，PyGObject 将自动编码/解码到 UTF-8。字符串或 *文本*将始终表示为 ："
"类：'str' 的实例仅：："

#: ../../source/unicode.txt:165
msgid "References"
msgstr "参考"

#: ../../source/unicode.txt:166
#, fuzzy
msgid ""
"`What's new in Python 3.0 <https://docs.python.org/3/whatsnew/3.0.html#text-"
"vs-data-instead-of-unicode-vs-8-bit>`_ describes the new concepts that "
"clearly distinguish between text and data."
msgstr ""
"Python 3.0 中的新功能< https：//docs.python.org/3/whatsnew/3.0.html#文本与数"
"据，而不是单码与 8 位>_ _ 描述了明确区分文本和数据的新概念。"

#: ../../source/unicode.txt:169
#, fuzzy
msgid ""
"The `Unicode HOWTO <https://docs.python.org/3/howto/unicode.html>`_ "
"discusses Python 2.x’s support for Unicode, and explains various problems "
"that people commonly encounter when trying to work with Unicode."
msgstr ""
"\"Unicode HOWTO <https：//docs.python.org/3/howto/Unicode.html>_ 讨论了 "
"Python 2.x 对 Unicode 的支持，并解释了人们在尝试使用 Unicode 时经常遇到的各种"
"问题。"

#: ../../source/unicode.txt:173
#, fuzzy
msgid ""
"The `Unicode HOWTO for Python 3.x <https://docs.python.org/dev/howto/unicode."
"html>`_ discusses Unicode support in Python 3.x."
msgstr ""
"\"Python 3.x <https：//docs.python.org/dev/howto/unicode.html>_ 讨论了 "
"Python 3.x 中的 Unicode 支持。"

#: ../../source/unicode.txt:176
#, fuzzy
msgid ""
"`UTF-8 encoding table and Unicode characters <https://www.utf8-chartable."
"de>`_ contains a list of Unicode code points and their respective UTF-8 "
"encoding."
msgstr ""
"\"UTF-8 编码表和 Unicode 字符 < https：//www.utf8-chartable.de>_ _ 包含 "
"Unicode 代码点及其各自的 UTF-8 编码的列表。"

#: ../../source/builder.txt:2
msgid "Glade and Gtk.Builder"
msgstr "Glade 和 Gtk.Builder"

#: ../../source/builder.txt:3
#, fuzzy
msgid ""
"The :class:`Gtk.Builder` class offers you the opportunity to design user "
"interfaces without writing a single line of code. This is possible through "
"describing the interface by an XML file and then loading the XML description "
"at runtime and create the objects automatically, which the Builder class "
"does for you. For the purpose of not needing to write the XML manually the "
"`Glade <https://glade.gnome.org/>`_ application lets you create the user "
"interface in a WYSIWYG (what you see is what you get) manner"
msgstr ""
"：class：'Gtk.Builder' 类为您提供了设计用户界面的机会，而无需编写一行代码。这"
"通过XML文件描述接口，然后在运行时加载XML描述并自动创建对象，这是通过生成器类"
"为您执行的。为了不需要手动编写 XML，\"Glade <https：//glade.gnome.org/>__ 应"
"用程序允许您以所见即见的方式创建用户界面（您所看到的是您得到的）"

#: ../../source/builder.txt:7
msgid "This method has several advantages:"
msgstr "此方法有几个优点："

#: ../../source/builder.txt:9
msgid "Less code needs to be written."
msgstr "需要编写的代码更少。"

#: ../../source/builder.txt:10
msgid "UI changes can be seen more quickly, so UIs are able to improve."
msgstr "UI 更改可以更快地看到，因此 UI 能够改进。"

#: ../../source/builder.txt:11
msgid "Designers without programming skills can create and edit UIs."
msgstr "没有编程技能的设计者可以创建和编辑 UIs。"

#: ../../source/builder.txt:12
msgid ""
"The description of the user interface is independent from the programming "
"language being used."
msgstr "用户界面的描述独立于使用的编程语言。"

#: ../../source/builder.txt:14
#, fuzzy
msgid ""
"There is still code required for handling interface changes triggered by the "
"user, but :class:`Gtk.Builder` allows you to focus on implementing that "
"functionality."
msgstr ""
"处理用户触发的接口更改仍然需要代码，但是 ：class：'Gtk.Builder' 允许您专注于"
"实现该功能。"

#: ../../source/builder.txt:17
msgid "Creating and loading the .glade file"
msgstr "创建和加载 .glade 文件"

#: ../../source/builder.txt:18
#, fuzzy
msgid ""
"First of all you have to download and install Glade. There are `several "
"tutorials <https://wiki.gnome.org/action/show/Apps/Glade/Tutorials>`_ about "
"Glade, so this is not explained here in detail. Let's start by creating a "
"window with a button in it and saving it to a file named *example.glade*. "
"The resulting XML file should look like this."
msgstr ""
"首先，你必须下载和安装格拉德。有\"几个教程<https：//wiki.gnome.org/行动/显示/"
"应用程序/格拉德/教程>'_关于格拉德，所以这里没有详细解释。让我们首先创建一个包"
"含按钮的窗口，然后保存到名为 *example.glade*的文件。生成的 XML 文件应看起来像"
"此。"

#: ../../source/builder.txt:41
#, fuzzy
msgid "To load this file in Python we need a :class:`Gtk.Builder` object."
msgstr "要在 Python 中加载此文件，我们需要一个 ：class：'Gtk.Builder'对象。"

#: ../../source/builder.txt:48
#, fuzzy
msgid ""
"The second line loads all objects defined in *example.glade* into the "
"Builder object."
msgstr "第二行将 *example. glade* 中定义的所有对象加载到 Builder 对象中。"

#: ../../source/builder.txt:50
#, fuzzy
msgid ""
"It is also possible to load only some of the objects. The following line "
"would add only the objects (and their child objects) given in the tuple."
msgstr "也可以只加载某些对象。以下行将仅添加元组中给出的对象（及其子对象）。"

#: ../../source/builder.txt:57
#, fuzzy
msgid ""
"These two methods exist also for loading from a string rather than a file. "
"Their corresponding names are :meth:`Gtk.Builder.add_from_string` and :meth:"
"`Gtk.Builder.add_objects_from_string` and they simply take a XML string "
"instead of a file name."
msgstr ""
"这两种方法也可用于从字符串而不是文件加载。他们的相应名称是：meth：'Gtk."
"Builder.add_from_string'和：meth：'Gtk.Builder.add_objects_from_string'，他们"
"只需使用XML字符串而不是文件名。"

#: ../../source/builder.txt:61
msgid "Accessing widgets"
msgstr "访问部件"

#: ../../source/builder.txt:62
#, fuzzy
msgid ""
"Now that the window and the button are loaded we also want to show them. "
"Therefore the :meth:`Gtk.Window.show_all` method has to be called on the "
"window. But how do we access the associated object?"
msgstr ""
"现在，窗口和按钮已加载，我们还要显示它们。因此，必须调用Gtk.Window."
"show_all：'Gtk.Window.show_all'方法。但是，我们如何访问关联的对象呢？"

#: ../../source/builder.txt:71
#, fuzzy
msgid ""
"Every widget can be retrieved from the builder by the :meth:`Gtk.Builder."
"get_object` method and the widget's *id*. It is really *that* simple."
msgstr ""
"每个小部件都可以通过：meth：'Gtk.Builder.get_object\"方法和小部件的 *id*从构"
"建器中检索。这真的很简单。"

#: ../../source/builder.txt:74
msgid "It is also possible to get a list of all objects with"
msgstr "还可以获取所有对象的列表"

#: ../../source/builder.txt:81
msgid "Connecting Signals"
msgstr "连接信号"

#: ../../source/builder.txt:82
#, fuzzy
msgid ""
"Glade also makes it possible to define signals which you can connect to "
"handlers in your code without extracting every object from the builder and "
"connecting to the signals manually. The first thing to do is to declare the "
"signal names in Glade. For this example we will act when the window is "
"closed and when the button was pressed, so we give the name \"onDestroy\" to "
"the callback handling the \"destroy\" signal of the window and "
"\"onButtonPressed\" to the callback handling the \"pressed\" signal of the "
"button. Now the XML file should look like this."
msgstr ""
"Glade 还能够定义信号，无需从构建器中提取每个对象并手动连接到信号，即可连接到"
"代码中的处理程序。要做的第一件事是在格拉德中声明信号名称。对于此示例，我们将"
"在窗口关闭和按下按钮时采取行动，因此，我们将名称\"onDestroy\"给回调处理窗口的"
"\"销毁\"信号和\"onButtonPressed\"到回调处理按钮的\"按下\"信号。现在，XML 文件"
"应该看起来像这样。"

#: ../../source/builder.txt:90
#, fuzzy
msgid ""
"Now we have to define the handler functions in our code. The *onDestroy* "
"should simply result in a call to :meth:`Gtk.main_quit`. When the button is "
"pressed we would like to print the string \"Hello World!\", so we define the "
"handler as follows"
msgstr ""
"现在，我们必须在代码中定义处理程序函数。*在德斯特罗伊*应该只是导致一个电话："
"meth：'Gtk.main_quit'。按下按钮时，我们要打印字符串\"Hello World！"

#: ../../source/builder.txt:99
#, fuzzy
msgid ""
"Next, we have to connect the signals and the handler functions. The easiest "
"way to do this is to define a *dict* with a mapping from the names to the "
"handlers and then pass it to the :meth:`Gtk.Builder.connect_signals` method."
msgstr ""
"接下来，我们必须连接信号和处理程序函数。最简单的方法是定义一个 *dict*，将映射"
"从名称映射到处理程序，然后将其传递给 ：meth：'Gtk.Builder.connect_signals\" "
"方法。"

#: ../../source/builder.txt:110
#, fuzzy
msgid ""
"An alternative approach is to create a class which has methods that are "
"called like the signals. In our example the last code snippet could be "
"rewritten as:"
msgstr ""
"另一种方法是创建一个类，该类具有与信号一样调用的方法。在我们的示例中，最后一"
"个代码段可以重写为："

#: ../../source/builder.txt:119
msgid "The final code of the example"
msgstr "示例的最终代码"

#: ../../source/entry.txt:2
msgid "Entry"
msgstr "条目"

#: ../../source/entry.txt:4
#, fuzzy
msgid ""
"Entry widgets allow the user to enter text. You can change the contents with "
"the :meth:`Gtk.Entry.set_text` method, and read the current contents with "
"the :meth:`Gtk.Entry.get_text` method. You can also limit the number of "
"characters the Entry can take by calling :meth:`Gtk.Entry.set_max_length`."
msgstr ""
"输入小部件允许用户输入文本。您可以使用：meth：'Gtk.Entry.set_text\"方法更改内"
"容，使用：meth：'Gtk.Entry.get_text当前内容。您还可以通过调用 ：meth：'Gtk."
"Entry.set_max_length\"来限制条目可以Gtk.Entry.set_max_length。"

#: ../../source/entry.txt:9
#, fuzzy
msgid ""
"Occasionally you might want to make an Entry widget read-only. This can be "
"done by passing ``False`` to the :meth:`Gtk.Entry.set_editable` method."
msgstr ""
"有时，您可能希望使\"条目\"小部件为只读。这可以通过将\"错误\"传递到："
"meth：'Gtk.Entry.set_editable方法。"

#: ../../source/entry.txt:12
#, fuzzy
msgid ""
"Entry widgets can also be used to retrieve passwords from the user. It is "
"common practice to hide the characters typed into the entry to prevent "
"revealing the password to a third party. Calling :meth:`Gtk.Entry."
"set_visibility` with ``False`` will cause the text to be hidden."
msgstr ""
"条目小部件也可用于从用户那里检索密码。通常的做法是隐藏输入的字符，以防止向第"
"三方透露密码。调用 ：meth：Gtk.Entry.set_visibility\"错误\"的\"错误\"将导致文"
"本隐藏。"

#: ../../source/entry.txt:17
#, fuzzy
msgid ""
":class:`Gtk.Entry` has the ability to display progress or activity "
"information behind the text. This is similar to :class:`Gtk.ProgressBar` "
"widget and is commonly found in web browsers to indicate how much of a page "
"download has been completed. To make an entry display such information, use :"
"meth:`Gtk.Entry.set_progress_fraction`, :meth:`Gtk.Entry."
"set_progress_pulse_step`, or :meth:`Gtk.Entry.progress_pulse`."
msgstr ""
"：类：\"Gtk.Entry\"能够显示文本后面的进度或活动信息。这类似于 ：class：'Gtk."
"ProgressBar' 小部件，通常在 Web 浏览器中找到，用于指示已完成多少页面下载。要"
"使条目显示此类信息，请使用：meth：'Gtk.Entry.set_progress_fraction'，：Gtk."
"Entry.set_progress_pulse_step\"，或：meth：'Gtk.Entry.progress_pulse'。"

#: ../../source/entry.txt:24
#, fuzzy
msgid ""
"Additionally, an Entry can show icons at either side of the entry. These "
"icons can be activatable by clicking, can be set up as drag source and can "
"have tooltips. To add an icon, use :meth:`Gtk.Entry.set_icon_from_icon_name` "
"or one of the various other functions that set an icon from an icon name, a "
"pixbuf, or icon theme. To set a tooltip on an icon, use :meth:`Gtk.Entry."
"set_icon_tooltip_text` or the corresponding function for markup."
msgstr ""
"此外，条目可以在条目的两侧显示图标。这些图标可以通过单击来操作，可以设置为拖"
"动源，并可以具有工具提示。要添加图标，请使用 ：meth：'Gtk.Entry."
"set_icon_from_icon_name'或从图标名称、pixbuf 或图标主题设置图标的各种其他函数"
"之一。若要在图标上设置工具提示，请使用 ：meth：'Gtk.Entry."
"set_icon_tooltip_text'或相应的标记函数。"

#: ../../source/basics.txt:4
msgid "Basics"
msgstr "基本"

#: ../../source/basics.txt:5
msgid "This section will introduce some of the most important aspects of GTK+."
msgstr "本节将介绍 GTK+ 的一些最重要的方面。"

#: ../../source/basics.txt:12
msgid "Main loop and Signals"
msgstr "主环路和信号"

#: ../../source/basics.txt:13
msgid ""
"Like most GUI toolkits, GTK+ uses an event-driven programming model. When "
"the user is doing nothing, GTK+ sits in the main loop and waits for input. "
"If the user performs some action - say, a mouse click - then the main loop "
"\"wakes up\" and delivers an event to GTK+."
msgstr ""
"与大多数 GUI 工具包一样，GTK+ 使用事件驱动的编程模型。当用户不执行任何操作"
"时，GTK+ 坐在主循环中等待输入。如果用户执行某些操作（例如，单击鼠标）则主循"
"环 \"唤醒\"，将事件传递到 GTK+。"

#: ../../source/basics.txt:18
#, fuzzy
msgid ""
"When widgets receive an event, they frequently emit one or more signals. "
"Signals notify your program that \"something interesting happened\" by "
"invoking functions you've connected to the signal. Such functions are "
"commonly known as *callbacks*. When your callbacks are invoked, you would "
"typically take some action - for example, when an Open button is clicked you "
"might display a file chooser dialog. After a callback finishes, GTK+ will "
"return to the main loop and await more user input."
msgstr ""
"当小部件收到事件时，它们经常发出一个或多个信号。信号通过调用连接到信号的函数"
"来通知程序\"发生了一些有趣的事情\"。此类函数通常称为 *回调*。调用回调时，通常"
"会执行一些操作 - 例如，单击\"打开\"按钮时，可能会显示文件选择器对话框。回调完"
"成后，GTK+ 将返回到主循环并等待更多用户输入。"

#: ../../source/basics.txt:28
msgid "A generic example is:"
msgstr "一个通用示例是："

#: ../../source/basics.txt:34
#, fuzzy
msgid ""
"Firstly, *widget* is an instance of a widget we created earlier. Next, the "
"event we are interested in. Each widget has its own particular events which "
"can occur. For instance, if you have a button you usually want to connect to "
"the \"clicked\" event. This means that when the button is clicked, the "
"signal is issued. Thirdly, the *callback* argument is the name of the "
"callback function. It contains the code which runs when signals of the "
"specified type are issued. Finally, the *data* argument includes any data "
"which should be passed when the signal is issued. However, this argument is "
"completely optional and can be left out if not required."
msgstr ""
"首先，*widget* 是我们之前创建的小部件的实例。接下来，我们感兴趣的活动。每个小"
"部件都有自己的特定事件，可以发生。例如，如果您有一个按钮，通常要连接到\"单击"
"\"事件。这意味着单击按钮时，将发出信号。第三，*回调*参数是回调函数的名称。它"
"包含发出指定类型信号时运行的代码。最后，*数据*参数包括发出信号时应传递的任何"
"数据。但是，此参数是完全可选的，如果不需要，可以省略。"

#: ../../source/basics.txt:46
#, fuzzy
msgid ""
"The function returns a number that identifies this particular signal-"
"callback pair. It is required to disconnect from a signal such that the "
"callback function will not be called during any future or currently ongoing "
"emissions of the signal it has been connected to."
msgstr ""
"函数返回标识此特定信号回调对的数字。需要断开与信号的连接，以便在未来或当前连"
"接信号的持续排放期间不会调用回调功能。"

#: ../../source/basics.txt:56
#, fuzzy
msgid ""
"If you have lost the \"handler_id\" for some reason (for example the "
"handlers were installed using :func:`Gtk.Builder.connect_signals`), you can "
"still disconnect a  specific callback using the function :func:"
"`disconnect_by_func`:"
msgstr ""
"如果由于某种原因handler_id\"handler_id\"（例如，处理程序是使用：func：'Gtk."
"Builder.connect_signals'安装的），您仍然可以使用函数 ："
"func：'disconnect_by_func'断开特定回调："

#: ../../source/basics.txt:64
#, fuzzy
msgid ""
"Applications should connect to the \"destroy\" signal of the top-level "
"window. It is emitted when an object is destroyed, so when a user requests "
"that a toplevel window is closed, the default handler for this signal "
"destroys the window, but does not terminate the application. Connecting the "
"\"destroy\" signal of the top-level window to the function :func:`Gtk."
"main_quit` will result in the desired behaviour."
msgstr ""
"应用程序应连接到顶级窗口的\"销毁\"信号。当对象被销毁时，它会发出，因此当用户"
"请求关闭顶级窗口时，此信号的默认处理程序将销毁该窗口，但不会终止应用程序。将"
"顶层窗口的\"销毁\"信号连接到函数：func：Gtk.main_quit\"将导致所需的行为。"

#: ../../source/basics.txt:74
#, fuzzy
msgid ""
"Calling :func:`Gtk.main_quit` makes the main loop inside of :func:`Gtk.main` "
"return."
msgstr "调用 ：func： 'Gtk.main_quit' 使主循环内 ： func： 'Gtk.main' 返回."

#: ../../source/basics.txt:77 ../../source/objects.txt:96
msgid "Properties"
msgstr "属性"

#: ../../source/basics.txt:78
#, fuzzy
msgid ""
"Properties describe the configuration and state of widgets. As for signals, "
"each widget has its own particular set of properties. For example, a button "
"has the property \"label\" which contains the text of the label widget "
"inside the button. You can specify the name and value of any number of "
"properties as keyword arguments when creating an instance of a widget. To "
"create a label aligned to the right with the text \"Hello World\" and an "
"angle of 25 degrees, use:"
msgstr ""
"属性描述小部件的配置和状态。至于信号，每个小部件都有其特定的属性集。例如，按"
"钮具有属性\"标签\"，其中包含按钮内标签小部件的文本。创建小部件实例时，可以指"
"定任何数量的属性的名称和值作为关键字参数。要创建与右侧对齐的标签，其文本为"
"\"Hello World\"，角度为 25 度，请使用："

#: ../../source/basics.txt:89
msgid "which is equivalent to"
msgstr "这相当于"

#: ../../source/basics.txt:98
#, fuzzy
msgid ""
"Instead of using getters and setters you can also get and set the gobject "
"properties through the \"props\" property such as ``widget.props.prop_name = "
"value``. This is equivalent to the more verbose ``widget.get_property(\"prop-"
"name\")`` and ``widget.set_property(\"prop-name\", value)``."
msgstr ""
"您也可以通过\"props\"属性（如\"'widget.props.prop_name=value\"）获取和设置属"
"性，而不是使用 getters 和设置器。这相当于更冗长的'widget.get_property（\"道具"
"名称\"）'和'widget.set_property（\"道具名称\"，值）\"。"

#: ../../source/basics.txt:103
#, fuzzy
msgid ""
"To see which properties are available for a widget in the running version of "
"GTK you can \"dir\" the \"props\" property:"
msgstr ""
"若要查看在运行版本的 GTK 中哪些属性可用于小部件，可以\"dir\"\"props\"属性："

#: ../../source/basics.txt:110
#, fuzzy
msgid "This will print in the console the list of properties a Gtk.Box has."
msgstr "这将在控制台中打印 Gtk.Box 具有的属性列表。"

#: ../../source/clipboard.txt:2
msgid "Clipboard"
msgstr "剪贴板"

#: ../../source/clipboard.txt:4
#, fuzzy
msgid ""
":class:`Gtk.Clipboard` provides a storage area for a variety of data, "
"including text and images. Using a clipboard allows this data to be shared "
"between applications through actions such as copying, cutting, and pasting. "
"These actions are usually done in three ways: using keyboard shortcuts, "
"using a :class:`Gtk.MenuItem`, and connecting the functions to :class:`Gtk."
"Button` widgets."
msgstr ""
"：类：'Gtk.Clipboard'提供了一个存储区域，用于各种数据，包括文本和图像。使用剪"
"贴板允许通过复制、剪切和粘贴等操作在应用程序之间共享此数据。这些操作通常通过"
"三种方式完成：使用键盘快捷键，使用 ：class：'Gtk.MenuItem'，以及将函数连接到 "
"：class：'Gtk.Button'小部件。"

#: ../../source/clipboard.txt:11
#, fuzzy
msgid ""
"There are multiple clipboard selections for different purposes. In most "
"circumstances, the selection named ``CLIPBOARD`` is used for everyday "
"copying and pasting. ``PRIMARY`` is another common selection which stores "
"text selected by the user with the cursor."
msgstr ""
"有多个剪贴板选择用于不同的目的。在大多数情况下，名为\"CLIPBOARD\"的选择用于日"
"常复制和粘贴。\"主要\"是另一个常见选择，它使用光标存储用户选择的文本。"

#: ../../source/cellrenderers.txt:4
msgid "CellRenderers"
msgstr "CellRenderers"

#: ../../source/cellrenderers.txt:6
#, fuzzy
msgid ""
":class:`Gtk.CellRenderer` widgets are used to display information within "
"widgets such as the :class:`Gtk.TreeView` or :class:`Gtk.ComboBox`. They "
"work closely with the associated widgets and are very powerful, with lots of "
"configuration options for displaying a large amount of data in different "
"ways. There are seven :class:`Gtk.CellRenderer` widgets which can be used "
"for different purposes:"
msgstr ""
"：类：'Gtk.CellRenderer'小部件用于在小部件中显示信息，如 ：class：'Gtk."
"TreeView' 或 ：class：'Gtk.ComboBox'。它们与关联的小部件密切合作，功能强大，"
"具有大量配置选项，可以不同的方式显示大量数据。有七个 ：class：'Gtk."
"CellRenderer'小部件，可用于不同的目的："

#: ../../source/cellrenderers.txt:12
msgid ":class:`Gtk.CellRendererText`"
msgstr ":class:`Gtk.CellRendererText`"

#: ../../source/cellrenderers.txt:13
msgid ":class:`Gtk.CellRendererToggle`"
msgstr ":class:`Gtk.CellRendererToggle`"

#: ../../source/cellrenderers.txt:14
msgid ":class:`Gtk.CellRendererPixbuf`"
msgstr ":class:`Gtk.CellRendererPixbuf`"

#: ../../source/cellrenderers.txt:15
msgid ":class:`Gtk.CellRendererCombo`"
msgstr ":class:`Gtk.CellRendererCombo`"

#: ../../source/cellrenderers.txt:16
msgid ":class:`Gtk.CellRendererProgress`"
msgstr ":class:`Gtk.CellRendererProgress`"

#: ../../source/cellrenderers.txt:17
msgid ":class:`Gtk.CellRendererSpinner`"
msgstr ":class:`Gtk.CellRendererSpinner`"

#: ../../source/cellrenderers.txt:18
msgid ":class:`Gtk.CellRendererSpin`"
msgstr ":class:`Gtk.CellRendererSpin`"

#: ../../source/cellrenderers.txt:19
msgid ":class:`Gtk.CellRendererAccel`"
msgstr ":class:`Gtk.CellRendererAccel`"

#: ../../source/cellrenderers.txt:22
msgid "CellRendererText"
msgstr "CellRendererText"

#: ../../source/cellrenderers.txt:24
#, fuzzy
msgid ""
"A :class:`Gtk.CellRendererText` renders a given text in its cell, using the "
"font, color and style information provided by its properties. The text will "
"be ellipsized if it is too long and the \"ellipsize\" property allows it."
msgstr ""
"A ：class：'Gtk.CellRenderrText' 使用其属性提供的字体、颜色和样式信息呈现其单"
"元格中的给定文本。如果文本太长且\"椭圆大小\"属性允许，它将进行椭圆调整。"

#: ../../source/cellrenderers.txt:28
#, fuzzy
msgid ""
"By default, text in :class:`Gtk.CellRendererText` widgets is not editable. "
"This can be changed by setting the value of the \"editable\" property to "
"``True``:"
msgstr ""
"默认情况下，：类中的文本：'Gtk.CellRendererText'小部件不可编辑。这可以通过将"
"\"可编辑\"属性的值设置为\"True\"来更改："

#: ../../source/cellrenderers.txt:35
#, fuzzy
msgid ""
"You can then connect to the \"edited\" signal and update your :class:`Gtk."
"TreeModel` accordingly."
msgstr "然后，您可以连接到\"编辑\"信号并相应地更新 ：class：'Gtk.TreeModel'。"

#: ../../source/cellrenderers.txt:47
msgid "CellRendererToggle"
msgstr "CellRendererToggle"

#: ../../source/cellrenderers.txt:49
#, fuzzy
msgid ""
":class:`Gtk.CellRendererToggle` renders a toggle button in a cell. The "
"button is drawn as a radio- or checkbutton, depending on the \"radio\" "
"property. When activated, it emits the \"toggled\" signal."
msgstr ""
"：类：'Gtk.CellrenderErToggle'在单元格中呈现切换按钮。按钮以无线电按钮或检查"
"按钮绘制，具体取决于\"无线电\"属性。激活后，它会发出\"切换\"信号。"

#: ../../source/cellrenderers.txt:53
#, fuzzy
msgid ""
"As a :class:`Gtk.CellRendererToggle` can have two states, active and not "
"active, you most likely want to bind the \"active\" property on the cell "
"renderer to a boolean value in the model, thus causing the check button to "
"reflect the state of the model."
msgstr ""
"作为 ：class：'Gtk.CellRendererToggle' 可以具有两种状态，即活动状态和未激活状"
"态，您很可能希望将单元格渲染器上的\"活动\"属性绑定到模型中的布尔值，从而导致"
"检查按钮反映模型的状态。"

#: ../../source/cellrenderers.txt:67
msgid "CellRendererPixbuf"
msgstr "CellRendererPixbuf"

#: ../../source/cellrenderers.txt:69
#, fuzzy
msgid ""
"A :class:`Gtk.CellRendererPixbuf` can be used to render an image in a cell. "
"It allows to render either a given :class:`Gdk.Pixbuf` (set via the \"pixbuf"
"\" property) or a named icon (set via the \"icon-name\" property)."
msgstr ""
"A 类：'Gtk.CellRendererPixbuf' 可用于在单元格中渲染图像。它允许呈现给定的 ："
"class：'Gdk.pixbuf'（通过\"pixbuf\"属性设置）或命名图标（通过\"图标名称\"属性"
"设置）。"

#: ../../source/cellrenderers.txt:82
msgid "CellRendererCombo"
msgstr "CellRendererCombo"

#: ../../source/cellrenderers.txt:84
#, fuzzy
msgid ""
":class:`Gtk.CellRendererCombo` renders text in a cell like :class:`Gtk."
"CellRendererText` from which it is derived. But while the latter offers a "
"simple entry to edit the text, :class:`Gtk.CellRendererCombo` offers a :"
"class:`Gtk.ComboBox` widget to edit the text. The values to display in the "
"combo box are taken from the :class:`Gtk.TreeModel` specified in the \"model"
"\" property."
msgstr ""
"：类：'Gtk.CellrendererCombo'在单元格中呈现文本，如 ：class：'Gtk."
"CellrendererText'，从中派生文本。但是，虽然后者提供了一个简单的条目来编辑文"
"本， ：class：'Gtk.CellRendererCombo' 提供了一个：类：'Gtk.ComboBox' 小部件来"
"编辑文本。要在组合框中显示的值取自 ：class：'Gtk.TreeModel\"在\"模型\"属性中"
"指定的值。"

#: ../../source/cellrenderers.txt:90
#, fuzzy
msgid ""
"The combo cell renderer takes care of adding a text cell renderer to the "
"combo box and sets it to display the column specified by its \"text-column\" "
"property."
msgstr ""
"组合单元格渲染器负责向组合框中添加文本单元格渲染器，并设置它以显示其\"文本列"
"\"属性指定的列。"

#: ../../source/cellrenderers.txt:93
#, fuzzy
msgid ""
"A :class:`Gtk.CellRendererCombo` can operate in two modes. It can be used "
"with and without an associated :class:`Gtk.Entry` widget, depending on the "
"value of the \"has-entry\" property."
msgstr ""
"A ：class：'Gtk.CellRendererCombo'可以在两种模式下运行。它可以与关联的 ："
"class：'Gtk.Entry' 小部件一起使用，具体取决于\"已输入\"属性的值。"

#: ../../source/cellrenderers.txt:106
msgid "CellRendererProgress"
msgstr "CellRendererProgress"

#: ../../source/cellrenderers.txt:108
#, fuzzy
msgid ""
":class:`Gtk.CellRendererProgress` renders a numeric value as a progress bar "
"in a cell. Additionally, it can display a text on top of the progress bar."
msgstr ""
"：类：'Gtk.CellRendererProgress'将数值呈现为单元格中的进度条。此外，它可以在"
"进度条顶部显示文本。"

#: ../../source/cellrenderers.txt:111
#, fuzzy
msgid ""
"The percentage value of the progress bar can be modified by changing the "
"\"value\" property. Similar to :class:`Gtk.ProgressBar`, you can enable the "
"*activity mode* by incrementing the \"pulse\" property instead of the \"value"
"\" property."
msgstr ""
"可以通过更改\"值\"属性来修改进度条的百分比值。与 ：class：'Gtk.ProgressBar' "
"类似，您可以通过增加\"脉冲\"属性而不是\"值\"属性来启用 *活动模式*。"

#: ../../source/cellrenderers.txt:124
msgid "CellRendererSpin"
msgstr "CellRendererSpin"

#: ../../source/cellrenderers.txt:126
#, fuzzy
msgid ""
":class:`Gtk.CellRendererSpin` renders text in a cell like :class:`Gtk."
"CellRendererText` from which it is derived. But while the latter offers a "
"simple entry to edit the text, :class:`Gtk.CellRendererSpin` offers a :class:"
"`Gtk.SpinButton` widget. Of course, that means that the text has to be "
"parseable as a floating point number."
msgstr ""
"：类：'Gtk.Cellrenderspin'在单元格中呈现文本，如 ：class：'Gtk."
"CellrendererText'，从该单元格中派生文本。但是，虽然后者提供了一个简单的条目来"
"编辑文本， ：class：'Gtk.CellRenderspin' 提供了一个：类：'Gtk.SpinButton'小部"
"件。当然，这意味着文本必须可解析为浮点数。"

#: ../../source/cellrenderers.txt:132
#, fuzzy
msgid ""
"The range of the spinbutton is taken from the adjustment property of the "
"cell renderer, which can be set explicitly or mapped to a column in the tree "
"model, like all properties of cell renders. :class:`Gtk.CellRendererSpin` "
"also has properties for the climb rate and the number of digits to display."
msgstr ""
"旋转按钮的范围取自单元格渲染器的调整属性，可以显式设置或映射到树模型中的列，"
"就像单元格渲染的所有属性一样。：类：'Gtk.CellRendererSpin'还具有爬升率和要显"
"示的数字的属性。"

#: ../../source/menus.txt:2 ../../source/application.txt:36
msgid "Menus"
msgstr "菜单"

#: ../../source/menus.txt:4
#, fuzzy
msgid ""
":class:`Gtk.UIManager`, :class:`Gtk.Action`, and :class:`Gtk.ActionGroup` "
"have been deprecated since GTK+ version 3.10 and should not be used in newly-"
"written code. Use the :ref:`application` framework instead."
msgstr ""
"：类：'Gtk.UIManager'，：类：'Gtk.Action'和：类：'Gtk.ActionGroup'自 GTK® 版"
"本 3.10 以来已弃用，不应在新编写的代码中使用。请改为使用 ：ref：'应用程序'框"
"架。"

#: ../../source/menus.txt:8
#, fuzzy
msgid ""
"GTK+ comes with two different types of menus, :class:`Gtk.MenuBar` and :"
"class:`Gtk.Toolbar`. :class:`Gtk.MenuBar` is a standard menu bar which "
"contains one or more :class:`Gtk.MenuItem` instances or one of its "
"subclasses. :class:`Gtk.Toolbar` widgets are used for quick accessibility to "
"commonly used functions of an application. Examples include creating a new "
"document, printing a page or undoing an operation. It contains one or more "
"instances of :class:`Gtk.ToolItem` or one of its subclasses."
msgstr ""
"GTK+ 附带两种不同类型的菜单：类：'Gtk.MenuBar'和：class：'Gtk.工具栏'。：类："
"\"Gtk.MenuBar\"是一个标准菜单栏，其中包含一个或多个 ：class：'Gtk.MenuItem' "
"实例或其子类之一。：类：'Gtk.Toolbar'小部件用于快速访问应用程序的常用功能。示"
"例包括创建新文档、打印页面或撤消操作。它包含 ：class 的一个或多个实例：'Gtk."
"ToolItem' 或其子类之一。"

#: ../../source/menus.txt:17 ../../source/application.txt:12
msgid "Actions"
msgstr "动作"

#: ../../source/menus.txt:19
#, fuzzy
msgid ""
"Although, there are specific APIs to create menus and toolbars, you should "
"use :class:`Gtk.UIManager` and create :class:`Gtk.Action` instances. Actions "
"are organised into groups. A :class:`Gtk.ActionGroup` is essentially a map "
"from names to :class:`Gtk.Action` objects. All actions that would make sense "
"to use in a particular context should be in a single group. Multiple action "
"groups may be used for a particular user interface. In fact, it is expected "
"that most non-trivial applications will make use of multiple groups. For "
"example, in an application that can edit multiple documents, one group "
"holding global actions (e.g. quit, about, new), and one group per document "
"holding actions that act on that document (eg. save, cut/copy/paste, etc). "
"Each window's menus would be constructed from a combination of two action "
"groups."
msgstr ""
"尽管有特定的 API 用于创建菜单和工具栏，但应使用 ：class：'Gtk.UIManager'并创"
"建 ：class：'Gtk.Action' 实例。行动被组织成小组。A ：class：'Gtk."
"ActionGroup' 本质上是从名称到 ：class 的映射：'Gtk.Action'对象。在特定上下文"
"中使用的所有有意义的操作都应在单个组中。多个操作组可用于特定的用户界面。事实"
"上，预计大多数非平凡的应用程序将使用多个组。例如，在可以编辑多个文档的应用程"
"序中，一个组保存全局操作（例如退出、大约、新），以及每个文档包含对该文档执行"
"操作的操作的一个组（例如保存、剪切/复制/粘贴等）。每个窗口的菜单将由两个操作"
"组的组合组成。"

#: ../../source/menus.txt:31
#, fuzzy
msgid "Different classes representing different types of actions exist:"
msgstr "存在表示不同类型的操作的不同类："

#: ../../source/menus.txt:33
#, fuzzy
msgid ""
":class:`Gtk.Action`: An action which can be triggered by a menu or toolbar "
"item"
msgstr "：类：\"Gtk.Action\"：可由菜单或工具栏项触发的操作"

#: ../../source/menus.txt:35
#, fuzzy
msgid ""
":class:`Gtk.ToggleAction`: An action which can be toggled between two states"
msgstr "：类：\"Gtk.切换行动\"：可以在两种状态之间切换的操作"

#: ../../source/menus.txt:36
#, fuzzy
msgid ""
":class:`Gtk.RadioAction`: An action of which only one in a group can be "
"active"
msgstr "：类：\"Gtk.RadioAction\"：组中只有一个可以处于活动状态的操作"

#: ../../source/menus.txt:38
#, fuzzy
msgid ""
":class:`Gtk.RecentAction`: An action of which represents a list of recently "
"used files"
msgstr "：类：\"Gtk.最近行动\"：其操作表示最近使用的文件列表"

#: ../../source/menus.txt:41
#, fuzzy
msgid ""
"Actions represent operations that the user can be perform, along with some "
"information how it should be presented in the interface, including its name "
"(not for display), its label (for display), an accelerator, whether a label "
"indicates a tooltip as well as the callback that is called when the action "
"gets activated."
msgstr ""
"操作表示用户可以执行的操作，以及一些在界面中应如何显示的操作，包括其名称（不"
"用于显示）、标签（用于显示）、加速器、标签是否指示工具提示以及激活操作时调用"
"的回调。"

#: ../../source/menus.txt:47
#, fuzzy
msgid ""
"You can create actions by either calling one of the constructors directly "
"and adding them to a :class:`Gtk.ActionGroup` by calling :meth:`Gtk."
"ActionGroup.add_action` or :meth:`Gtk.ActionGroup.add_action_with_accel`, or "
"by calling one of the convenience functions:"
msgstr ""
"您可以通过直接调用其中一个构造函数并将它们添加到 ：class：'Gtk.ActionGroup'来"
"创建操作：Gtk.ActionGroup.add_action\"或：meth：'Gtk.ActionGroup."
"add_action_with_accel'，或者调用其中一个方便函数："

#: ../../source/menus.txt:52
msgid ":meth:`Gtk.ActionGroup.add_actions`,"
msgstr ":meth:`Gtk.ActionGroup.add_actions`,"

#: ../../source/menus.txt:53
msgid ":meth:`Gtk.ActionGroup.add_toggle_actions`"
msgstr ":meth:`Gtk.ActionGroup.add_toggle_actions`"

#: ../../source/menus.txt:54
msgid ":meth:`Gtk.ActionGroup.add_radio_actions`."
msgstr ":meth:`Gtk.ActionGroup.add_radio_actions`."

#: ../../source/menus.txt:56
msgid "Note that you must specify actions for sub menus as well as menu items."
msgstr "请注意，您必须为子菜单和菜单项指定操作。"

#: ../../source/menus.txt:59
msgid "UI Manager"
msgstr "UI 管理器"

#: ../../source/menus.txt:61
#, fuzzy
msgid ""
":class:`Gtk.UIManager` provides an easy way of creating menus and toolbars "
"using an `XML-like description <https://developer.gnome.org/gtk3/stable/"
"GtkUIManager.html#XML-UI>`_."
msgstr ""
"：类：\"Gtk.UIManager\"提供了一种使用\"XML类描述<https：//开发人员.gnome.org/"
"gtk3/稳定/GtkUIManager.html#XML-UI>_创建菜单和工具栏的一种简单方法。"

#: ../../source/menus.txt:64
#, fuzzy
msgid ""
"First of all, you should add the :class:`Gtk.ActionGroup` to the UI Manager "
"with :meth:`Gtk.UIManager.insert_action_group`. At this point is also a good "
"idea to tell the parent window to respond to the specified keyboard "
"shortcuts, by using :meth:`Gtk.UIManager.get_accel_group` and :meth:`Gtk."
"Window.add_accel_group`."
msgstr ""
"首先，您应该将 ：class：'Gtk.ActionGroup' 添加到 UI 管理器中，使用 ："
"meth：'Gtk.UIManager.insert_action_group\"。在这一点上也是一个好主意，告诉父"
"窗口响应指定的键盘快捷键，使用：meth：'Gtk.UIManager.get_accel_group'和："
"meth：'Gtk.Window.add_accel_group'。"

#: ../../source/menus.txt:69
#, fuzzy
msgid ""
"Then, you can define the actual visible layout of the menus and toolbars, "
"and add the UI layout. This \"ui string\" uses an XML format, in which you "
"should mention the names of the actions that you have already created. "
"Remember that these names are just the identifiers that we used when "
"creating the actions. They are not the text that the user will see in the "
"menus and toolbars. We provided those human-readable names when we created "
"the actions."
msgstr ""
"然后，您可以定义菜单和工具栏的实际可见布局，并添加 UI 布局。此\"ui 字符串\"使"
"用 XML 格式，其中应提及已创建的操作的名称。请记住，这些名称只是我们在创建操作"
"时使用的标识符。它们不是用户将在菜单和工具栏中看到的文本。当我们创建操作时，"
"我们提供了这些人类可读的名称。"

#: ../../source/menus.txt:76
#, fuzzy
msgid ""
"Finally, you retrieve the root widget with :meth:`Gtk.UIManager.get_widget` "
"and add the widget to a container such as :class:`Gtk.Box`."
msgstr ""
"最后，使用 ：meth：'Gtk.UIManager.get_widget\"检索根小部件，并将小部件添加到"
"容器中，如 ：class：'Gtk.Box'。"

#: ../../source/textview.txt:2
msgid "Multiline Text Editor"
msgstr "多行文本编辑器"

#: ../../source/textview.txt:4
#, fuzzy
msgid ""
"The :class:`Gtk.TextView` widget can be used to display and edit large "
"amounts of formatted text. Like the :class:`Gtk.TreeView`, it has a model/"
"view design. In this case the :class:`Gtk.TextBuffer` is the model which "
"represents the text being edited. This allows two or more :class:`Gtk."
"TextView` widgets to share the same :class:`Gtk.TextBuffer`, and allows "
"those text buffers to be displayed slightly differently. Or you could "
"maintain several text buffers and choose to display each one at different "
"times in the same :class:`Gtk.TextView` widget."
msgstr ""
"：class：'Gtk.TextView' 小部件可用于显示和编辑大量格式化的文本。就像 ："
"class：'Gtk.TreeView'一样，它有一个模型/视图设计。在这种情况下，："
"class：'Gtk.TextBuffer' 是表示正在编辑的文本的模型。这允许两个或多个 ："
"class：'Gtk.TextView' 小部件共享相同的 ：class：'Gtk.TextBuffer'，并允许这些"
"文本缓冲区的显示略有不同。或者，您可以维护多个文本缓冲区，并选择在同一"
"类：'Gtk.TextView'小部件的不同时间显示每个缓冲区。"

#: ../../source/textview.txt:13 ../../source/treeview.txt:141
msgid "The View"
msgstr "视图"

#: ../../source/textview.txt:15
#, fuzzy
msgid ""
"The :class:`Gtk.TextView` is the frontend with which the user can add, edit "
"and delete textual data. They are commonly used to edit multiple lines of "
"text. When creating a :class:`Gtk.TextView` it contains its own default :"
"class:`Gtk.TextBuffer`, which you can access via the :meth:`Gtk.TextView."
"get_buffer` method."
msgstr ""
"：class：'Gtk.TextView' 是用户可以添加、编辑和删除文本数据的前端。它们通常用"
"于编辑多行文本。创建 ：class：'Gtk.TextView 时，它包含自己的默认值："
"class：'Gtk.TextBuffer'，您可以通过：meth：'Gtk.TextView.get_buffer\"方法访"
"问。"

#: ../../source/textview.txt:21
#, fuzzy
msgid ""
"By default, text can be added, edited and removed from the :class:`Gtk."
"TextView`. You can disable this by calling :meth:`Gtk.TextView."
"set_editable`. If the text is not editable, you usually want to hide the "
"text cursor with :meth:`Gtk.TextView.set_cursor_visible` as well. In some "
"cases it may be useful to set the justification of the text with :meth:`Gtk."
"TextView.set_justification`. The text can be displayed at the left edge, (:"
"attr:`Gtk.Justification.LEFT`), at the right edge (:attr:`Gtk.Justification."
"RIGHT`), centered (:attr:`Gtk.Justification.CENTER`), or distributed across "
"the complete width (:attr:`Gtk.Justification.FILL`)."
msgstr ""
"默认情况下，可以从 ：class 添加、编辑和删除文本：'Gtk.TextView'。您可以通过调"
"用 ：meth：'Gtk.TextView.set_editable\" 来禁用此功能。如果文本不可编辑，您通"
"常希望使用 ：meth：'Gtk.TextView.set_cursor_visible'来隐藏文本光标。在某些情"
"况下，使用 ：meth：'Gtk.TextView.set_justification' 来设置文本的对齐方式。文"
"本可以显示在左边缘（：attr：'Gtk.解释.左'），在右边缘（：attr：'Gtk.解释."
"右'），居中（：attr：'Gtk.解释.中心'），或分布在整个宽度（：attr：'Gtk.解释."
"FILL'）。"

#: ../../source/textview.txt:31
#, fuzzy
msgid ""
"Another default setting of the :class:`Gtk.TextView` widget is long lines of "
"text will continue horizontally until a break is entered. To wrap the text "
"and prevent it going off the edges of the screen call :meth:`Gtk.TextView."
"set_wrap_mode`."
msgstr ""
"：class：'Gtk.TextView' 小部件的另一个默认设置是一长行文本将继续水平显示，直"
"到输入中断。要包装文本，并防止它离开屏幕的边缘调用：meth：'Gtk.TextView."
"set_wrap_mode'。"

#: ../../source/textview.txt:36 ../../source/treeview.txt:21
msgid "The Model"
msgstr "模型"

#: ../../source/textview.txt:38
#, fuzzy
msgid ""
"The :class:`Gtk.TextBuffer` is the core of the :class:`Gtk.TextView` widget, "
"and is used to hold whatever text is being displayed in the :class:`Gtk."
"TextView`. Setting and retrieving the contents is possible with :meth:`Gtk."
"TextBuffer.set_text` and :meth:`Gtk.TextBuffer.get_text`. However, most text "
"manipulation is accomplished with *iterators*, represented by a :class:`Gtk."
"TextIter`. An iterator represents a position between two characters in the "
"text buffer. Iterators are not valid indefinitely; whenever the buffer is "
"modified in a way that affects the contents of the buffer, all outstanding "
"iterators become invalid."
msgstr ""
"：class：'Gtk.TextBuffer' 是 ：class：'Gtk.TextView' 小部件的核心，用于保存 "
"：class 中显示的任何文本：'Gtk.TextView'。设置和检索内容是可能的：meth：'Gtk."
"TextBuffer.set_text'和：meth：'Gtk.TextBuffer.get_text'。但是，大多数文本操作"
"都是使用 *循环器* 完成的，由 ：class 表示：'Gtk.TextIter'。一个数据器表示文本"
"缓冲区中两个字符之间的位置。数据器在不确定时无效;每当以影响缓冲区内容的方式修"
"改缓冲区时，所有未完成的流量都变得无效。"

#: ../../source/textview.txt:48
#, fuzzy
msgid ""
"Because of this, iterators can't be used to preserve positions across buffer "
"modifications. To preserve a position, use :class:`Gtk.TextMark`. A text "
"buffer contains two built-in marks; an \"insert\" mark (which is the "
"position of the cursor) and the \"selection_bound\" mark. Both of them can "
"be retrieved using :meth:`Gtk.TextBuffer.get_insert` and :meth:`Gtk."
"TextBuffer.get_selection_bound`, respectively. By default, the location of "
"a :class:`Gtk.TextMark` is not shown. This can be changed by calling :meth:"
"`Gtk.TextMark.set_visible`."
msgstr ""
"因此，不能使用遍数器在缓冲区修改之间保留位置。要保留位置，请使用 ："
"class：'Gtk.TextMark'。文本缓冲区包含两个内置标记;\"插入\"标记（即光标的位"
"置）和\"selection_bound\"标记。它们都可以分别使用：meth：'Gtk.TextBuffer."
"get_insert'和：'Gtk.TextBuffer.get_selection_bound'进行检索。默认情况下，不显"
"示 ：class：'Gtk.TextMark'的位置。这可以通过调用：meth：'Gtk.TextMark."
"set_visible。"

#: ../../source/textview.txt:56
#, fuzzy
msgid ""
"Many methods exist to retrieve a :class:`Gtk.TextIter`. For instance, :meth:"
"`Gtk.TextBuffer.get_start_iter` returns an iterator pointing to the first "
"position in the text buffer, whereas :meth:`Gtk.TextBuffer.get_end_iter` "
"returns an iterator pointing past the last valid character. Retrieving the "
"bounds of the selected text can be achieved by calling :meth:`Gtk.TextBuffer."
"get_selection_bounds`."
msgstr ""
"有许多方法可以检索 ：class：'Gtk.Textiter'。例如：meth：'Gtk.TextBuffer."
"get_start_iter'返回指向文本缓冲区中第一个位置的度量器，而 ：meth：'Gtk."
"TextBuffer.get_end_iter' 返回指向最后一个有效字符的度量器。检索所选文本的界限"
"可以通过调用 ：meth：'Gtk.TextBuffer.get_selection_bounds\" 实现。"

#: ../../source/textview.txt:63
#, fuzzy
msgid ""
"To insert text at a specific position use :meth:`Gtk.TextBuffer.insert`. "
"Another useful method is :meth:`Gtk.TextBuffer.insert_at_cursor` which "
"inserts text wherever the cursor may be currently positioned. To remove "
"portions of the text buffer use :meth:`Gtk.TextBuffer.delete`."
msgstr ""
"要在特定位置插入文本，请使用 ：meth：'Gtk.TextBuffer.插入'。另一种有用的方法"
"是：meth：'Gtk.TextBuffer.insert_at_cursor'，它插入文本，无论光标当前可能位于"
"何处。要删除部分文本缓冲区，请使用 ：meth：'Gtk.TextBuffer.delete'。"

#: ../../source/textview.txt:68
#, fuzzy
msgid ""
"In addition, :class:`Gtk.TextIter` can be used to locate textual matches in "
"the buffer using :meth:`Gtk.TextIter.forward_search` and :meth:`Gtk.TextIter."
"backward_search`. The start and end iters are used as the starting point of "
"the search and move forwards/backwards depending on requirements."
msgstr ""
"此外，：类：'Gtk.TextIter'可用于使用：meth：'Gtk.TextIter.forward_search"
"\"和：meth：'Gtk.TextIter.backward_search'在缓冲区中定位文本匹配。开始和结束 "
"it 器用作搜索的起点，并根据要求向前/向后移动。"

#: ../../source/textview.txt:75
msgid "Tags"
msgstr "标签"

#: ../../source/textview.txt:77
#, fuzzy
msgid ""
"Text in a buffer can be marked with tags. A tag is an attribute that can be "
"applied to some range of text. For example, a tag might be called \"bold\" "
"and make the text inside the tag bold. However, the tag concept is more "
"general than that; tags don't have to affect appearance. They can instead "
"affect the behaviour of mouse and key presses, \"lock\" a range of text so "
"the user can't edit it, or countless other things. A tag is represented by "
"a :class:`Gtk.TextTag` object. One :class:`Gtk.TextTag` can be applied to "
"any number of text ranges in any number of buffers."
msgstr ""
"缓冲区中的文本可以使用标记进行标记。标记是可应用于某些文本范围的属性。例如，"
"标记可能称为\"粗体\"，使标记内的文本为粗体。然而，标记概念比这更笼统;标记不必"
"影响外观。相反，它们可以影响鼠标和按键的行为，\"锁定\"一系列文本，以便用户无"
"法编辑它，或无数其他内容。标记由 ：class 表示：'Gtk.TextTag' 对象。一 ：类："
"\"Gtk.TextTag\"可应用于任何数量的缓冲区中的任何数量的文本范围。"

#: ../../source/textview.txt:86
#, fuzzy
msgid ""
"Each tag is stored in a :class:`Gtk.TextTagTable`. A tag table defines a set "
"of tags that can be used together. Each buffer has one tag table associated "
"with it; only tags from that tag table can be used with the buffer. A single "
"tag table can be shared between multiple buffers, however."
msgstr ""
"每个标记都存储在 ：class：'Gtk.TextTagTable'中。标记表定义一组可以一起使用的"
"标记。每个缓冲区都有一个与其关联的标记表;只有该标记表中的标记可以与缓冲区一起"
"使用。但是，可以在多个缓冲区之间共享单个标记表。"

#: ../../source/textview.txt:91
#, fuzzy
msgid ""
"To specify that some text in the buffer should have specific formatting, you "
"must define a tag to hold that formatting information, and then apply that "
"tag to the region of text using :meth:`Gtk.TextBuffer.create_tag` and :meth:"
"`Gtk.TextBuffer.apply_tag`::"
msgstr ""
"若要指定缓冲区中某些文本应具有特定的格式，必须定义一个标记来保存该格式信息，"
"然后使用 ：meth：'Gtk.TextBuffer.create_tag'和 ：meth：'Gtk.TextBuffer."
"apply_tag'将该标记应用于文本区域："

#: ../../source/textview.txt:99
#, fuzzy
msgid "The following are some of the common styles applied to text:"
msgstr "以下是应用于文本的一些常见样式："

#: ../../source/textview.txt:101
msgid "Background colour (\"foreground\" property)"
msgstr "背景颜色（\"前景\" 属性）"

#: ../../source/textview.txt:102
msgid "Foreground colour (\"background\" property)"
msgstr "前景颜色（\"背景\" 属性）"

#: ../../source/textview.txt:103
msgid "Underline (\"underline\" property)"
msgstr "下划线（\"下划线\" 属性）"

#: ../../source/textview.txt:104
msgid "Bold (\"weight\" property)"
msgstr "粗体（\"加粗\" 属性）"

#: ../../source/textview.txt:105
msgid "Italics (\"style\" property)"
msgstr "斜体（\"样式\" 属性）"

#: ../../source/textview.txt:106
msgid "Strikethrough (\"strikethrough\" property)"
msgstr "删除（\"删除\" 属性）"

#: ../../source/textview.txt:107
msgid "Justification (\"justification\" property)"
msgstr "对齐（\"对齐\" 属性）"

#: ../../source/textview.txt:108
msgid "Size (\"size\" and \"size-points\" properties)"
msgstr "大小（\"大小\"和\"大小点\"属性）"

#: ../../source/textview.txt:109
msgid "Text wrapping (\"wrap-mode\" property)"
msgstr "文本换行（\"换行模式\"属性）"

#: ../../source/textview.txt:111
#, fuzzy
msgid ""
"You can also delete particular tags later using :meth:`Gtk.TextBuffer."
"remove_tag` or delete all tags in a given region by calling :meth:`Gtk."
"TextBuffer.remove_all_tags`."
msgstr ""
"您也可以稍后使用 ：meth：'Gtk.TextBuffer.remove_tag'删除特定标记，或者通过调"
"用 ：meth：'Gtk.TextBuffer.remove_all_tags 删除给定区域的所有标记。"

#: ../../source/label.txt:2
msgid "Label"
msgstr "标签"

#: ../../source/label.txt:4
#, fuzzy
msgid ""
"Labels are the main method of placing non-editable text in windows, for "
"instance to place a title next to a :class:`Gtk.Entry` widget. You can "
"specify the text in the constructor, or later with the :meth:`Gtk.Label."
"set_text` or :meth:`Gtk.Label.set_markup` methods."
msgstr ""
"标签是将不可编辑文本放在窗口中的主要方法，例如在 ：class：'Gtk.Entry' 小部件"
"旁边放置标题。您可以在构造函数中指定文本，也可以稍后使用 ：meth：'Gtk.Label."
"set_text'或：meth：'Gtk.Label.set_markup方法。"

#: ../../source/label.txt:9
#, fuzzy
msgid ""
"The width of the label will be adjusted automatically. You can produce multi-"
"line labels by putting line breaks (\"\\\\n\") in the label string."
msgstr ""
"标签的宽度将自动调整。您可以通过在标签字符串中放置换行符（\"\\n\"）来生成多行"
"标签。"

#: ../../source/label.txt:12
#, fuzzy
msgid ""
"Labels can be made selectable with :meth:`Gtk.Label.set_selectable`. "
"Selectable labels allow the user to copy the label contents to the "
"clipboard. Only labels that contain useful-to-copy information — such as "
"error messages — should be made selectable."
msgstr ""
"标签可以选择：冰毒：'Gtk.Label.set_selectable'。可选标签允许用户将标签内容复"
"制到剪贴板。只有包含有用复制信息（如错误消息）的标签才应进行选择。"

#: ../../source/label.txt:17
#, fuzzy
msgid ""
"The label text can be justified using the :meth:`Gtk.Label.set_justify` "
"method. The widget is also capable of word-wrapping, which can be activated "
"with :meth:`Gtk.Label.set_line_wrap`."
msgstr ""
"标签文本可以使用 ：meth：'Gtk.Label.set_justify法。小部件也能够进行文字包装，"
"可以使用：meth：'Gtk.Label.set_line_wrap'激活。"

#: ../../source/label.txt:21
#, fuzzy
msgid ""
":class:`Gtk.Label` support some simple formatting, for instance allowing you "
"to make some text bold, colored, or larger. You can do this by providing a "
"string to :meth:`Gtk.Label.set_markup`, using the Pango Markup syntax "
"[#pango]_. For instance, ``<b>bold text</b> and <s>strikethrough text</s>``. "
"In addition, :class:`Gtk.Label` supports clickable hyperlinks. The markup "
"for links is borrowed from HTML, using the a with href and title attributes. "
"GTK+ renders links similar to the way they appear in web browsers, with "
"colored, underlined text. The title attribute is displayed as a tooltip on "
"the link."
msgstr ""
"：类：'Gtk.Label'支持一些简单的格式设置，例如允许您使某些文本加粗、彩色或更"
"大。您可以通过使用 Pango 标记语法 [#pango]向 ：meth：'Gtk.Label.set_markup'提"
"供字符串来做到这一点。例如，\"粗<b>体文本</b><s>和删除文本</s>\"。此外，："
"类：'Gtk.Label'支持可单击的超链接。链接的标记是从 HTML 借用的，使用带 href 和"
"标题属性的 a。GTK+ 呈现的链接与它们在 Web 浏览器中的显示方式类似，带有彩色下"
"划线文本。标题属性在链接上显示为工具提示。"

#: ../../source/label.txt:37
#, fuzzy
msgid ""
"Labels may contain *mnemonics*. Mnemonics are underlined characters in the "
"label, used for keyboard navigation. Mnemonics are created by providing a "
"string with an underscore before the mnemonic character, such as \"_File\", "
"to the functions :meth:`Gtk.Label.new_with_mnemonic` or :meth:`Gtk.Label."
"set_text_with_mnemonic`. Mnemonics automatically activate any activatable "
"widget the label is inside, such as a :class:`Gtk.Button`; if the label is "
"not inside the mnemonic's target widget, you have to tell the label about "
"the target using :meth:`Gtk.Label.set_mnemonic_widget`."
msgstr ""
"标签可能包含 *mnemonics*。女士是标签中的带下划线字符，用于键盘导航。通过提供"
"一个带下划线的字符串，例如\"_File\"，以函数：meth：'Gtk.Label."
"new_with_mnemonic'或：meth：'Gtk.Label.set_text_with_mnemonic'创建。"
"Mnemonics 自动激活标签内的任何可激活小部件，例如 ：class：'Gtk.Button';如果标"
"签不在微音的目标小部件内，您必须使用：meth：'Gtk.Label.set_mnemonic_widget"
"\"告诉标签。"

#: ../../source/label.txt:55
#, fuzzy
msgid ""
"Pango Markup Syntax, https://developer.gnome.org/pango/stable/pango-Markup."
"html"
msgstr ""
"潘戈标记语法，https://developer.gnome.org/pango/stable/pango-Markup.html"

#: ../../source/treeview.txt:2
msgid "Tree and List Widgets"
msgstr "树和列表部件"

#: ../../source/treeview.txt:4
#, fuzzy
msgid ""
"A :class:`Gtk.TreeView` and its associated widgets are an extremely powerful "
"way of displaying data. They are used in conjunction with a :class:`Gtk."
"ListStore` or :class:`Gtk.TreeStore` and provide a way of displaying and "
"manipulating data in many ways, including:"
msgstr ""
"A ：class：'Gtk.TreeView' 及其关联的小部件是显示数据的极其强大的方式。它们与 "
"：class：'Gtk.listStore'或 ：class：'Gtk.TreeStore）结合使用，并提供一种以多"
"种方式显示和操作数据的方法，包括："

#: ../../source/treeview.txt:9
msgid "Automatic updates when data is added, removed or edited"
msgstr "添加、删除或编辑数据时自动更新"

#: ../../source/treeview.txt:10
msgid "Drag and drop support"
msgstr "拖放支持"

#: ../../source/treeview.txt:11
msgid "Sorting data"
msgstr "对数据进行排序"

#: ../../source/treeview.txt:12
msgid "Embedding widgets such as check boxes, progress bars, etc."
msgstr "嵌入部件，如复选框、进度条等。"

#: ../../source/treeview.txt:13
msgid "Reorderable and resizable columns"
msgstr "可重新排序和可调整大小的列"

#: ../../source/treeview.txt:14
msgid "Filtering data"
msgstr "筛选数据"

#: ../../source/treeview.txt:16
#, fuzzy
msgid ""
"With the power and flexibility of a :class:`Gtk.TreeView` comes complexity. "
"It is often difficult for beginner developers to be able to utilize it "
"correctly due to the number of methods which are required."
msgstr ""
"随着 ：class：'Gtk.TreeView'的功率和灵活性，复杂性也来了。由于需要的方法数量"
"很多，初学者开发人员通常很难正确利用它。"

#: ../../source/treeview.txt:22
#, fuzzy
msgid ""
"Each :class:`Gtk.TreeView` has an associated :class:`Gtk.TreeModel`, which "
"contains the data displayed by the TreeView. Each :class:`Gtk.TreeModel` can "
"be used by more than one :class:`Gtk.TreeView`. For instance, this allows "
"the same underlying data to be displayed and edited in 2 different ways at "
"the same time. Or the 2 Views might display different columns from the same "
"Model data, in the same way that 2 SQL queries (or \"views\") might show "
"different fields from the same database table."
msgstr ""
"每个 ：class：'Gtk.TreeView' 具有关联的 ：class：'Gtk.TreeModel'，其中包含 "
"TreeView 显示的数据。每个 ：class：'Gtk.TreeModel' 可由多个 ：class：'Gtk."
"TreeView'使用。例如，这允许同时以 2 种不同的方式显示和编辑相同的基础数据。或"
"者，2 个视图可能显示来自相同模型数据的不同列，就像 2 个 SQL 查询（或\"视图"
"\"）可能显示同一个数据库表中的不同字段一样。"

#: ../../source/treeview.txt:30
#, fuzzy
msgid ""
"Although you can theoretically implement your own Model, you will normally "
"use either the :class:`Gtk.ListStore` or :class:`Gtk.TreeStore` model "
"classes. :class:`Gtk.ListStore` contains simple rows of data, and each row "
"has no children, whereas :class:`Gtk.TreeStore` contains rows of data, and "
"each row may have child rows."
msgstr ""
"虽然理论上可以实现自己的模型，但通常使用 ：class：'Gtk.listStore' 或 ："
"class：'Gtk.TreeStore' 模型类。：类：'Gtk.ListStore' 包含简单的数据行，并且每"
"行没有子行，而 ：class：'Gtk.TreeStore' 包含数据行，并且每行可能都有子行。"

#: ../../source/treeview.txt:36
#, fuzzy
msgid ""
"When constructing a model you have to specify the data types for each column "
"the model holds."
msgstr "构造模型时，必须为模型持有的每一列指定数据类型。"

#: ../../source/treeview.txt:43
#, fuzzy
msgid ""
"This creates a list store with three columns, two string columns, and a "
"float column."
msgstr "这将创建一个包含三列、两个字符串列和浮列的列表存储。"

#: ../../source/treeview.txt:46
#, fuzzy
msgid ""
"Adding data to the model is done using :meth:`Gtk.ListStore.append` or :meth:"
"`Gtk.TreeStore.append`, depending upon which sort of model was created."
msgstr ""
"向模型添加数据是使用 ：meth：'Gtk.ListStore.附加' 或 ：meth：'Gtk.TreeStore."
"附加'完成的，具体取决于创建的模型类型。"

#: ../../source/treeview.txt:54
#, fuzzy
msgid ""
"Both methods return a :class:`Gtk.TreeIter` instance, which points to the "
"location of the newly inserted row. You can retrieve a :class:`Gtk.TreeIter` "
"by calling :meth:`Gtk.TreeModel.get_iter`."
msgstr ""
"两种方法都返回 ：class：'Gtk.TreeIter' 实例，该实例指向新插入的行的位置。您可"
"以通过调用 ：meth：'Gtk.TreeModel.get_iter\" 来检索 ：class： 'Gtk."
"Treeiter'。"

#: ../../source/treeview.txt:58
#, fuzzy
msgid ""
"Once data has been inserted, you can retrieve or modify data using the tree "
"iter and column index."
msgstr "插入数据后，可以使用树索引和列索引检索或修改数据。"

#: ../../source/treeview.txt:66
#, fuzzy
msgid ""
"As with Python's built-in :class:`list` object you can use :func:`len` to "
"get the number of rows and use slices to retrieve or set values."
msgstr ""
"与 Python 的内置 ：class：'list'对象一样，您可以使用 ：func：'len 获取行数，"
"并使用切片检索或设置值。"

#: ../../source/treeview.txt:80
#, fuzzy
msgid "Iterating over all rows of a tree model is very simple as well."
msgstr "对树模型的所有行进行遍数也非常简单。"

#: ../../source/treeview.txt:88
#, fuzzy
msgid ""
"Keep in mind, that if you use :class:`Gtk.TreeStore`, the above code will "
"only iterate over the rows of the top level, but not the children of the "
"nodes. To iterate over all rows and its children, use the "
"``print_tree_store`` function."
msgstr ""
"请记住，如果使用 ：class：'Gtk.TreeStore'，则上述代码只会遍流顶层的行，而不是"
"节点的子级。若要遍用它来迭代所有行及其子行，请使用\"print_tree_store\"函数。"

#: ../../source/treeview.txt:106
#, fuzzy
msgid ""
"Apart from accessing values stored in a :class:`Gtk.TreeModel` with the list-"
"like method mentioned above, it is also possible to either use :class:`Gtk."
"TreeIter` or :class:`Gtk.TreePath` instances. Both reference a particular "
"row in a tree model. One can convert a path to an iterator by calling :meth:"
"`Gtk.TreeModel.get_iter`. As :class:`Gtk.ListStore` contains only one level, "
"i.e. nodes do not have any child nodes, a path is essentially the index of "
"the row you want to access."
msgstr ""
"除了使用上述列表方法访问存储在 ：class：'Gtk.TreeModel'中的值外，还可以使用 "
"：class：'Gtk.TreeIter' 或 ：class：'Gtk.TreePath' 实例。两者都引用树模型中的"
"特定行。可以通过调用 ：meth：'Gtk.TreeModel.get_iter'将路径转换为Gtk."
"TreeModel.get_iter。作为 ：class：'Gtk.ListStore'只包含一个级别，即节点没有任"
"何子节点，路径本质上是要访问的行的索引。"

#: ../../source/treeview.txt:123
#, fuzzy
msgid ""
"In the case of :class:`Gtk.TreeStore`, a path is a list of indexes or a "
"string. The string form is a list of numbers separated by a colon. Each "
"number refers to the offset at that level. Thus, the path \"0\" refers to "
"the root node and the path \"2:4\" refers to the fifth child of the third "
"node."
msgstr ""
"在 ：class：'Gtk.TreeStore' 的情况下，路径是索引或字符串的列表。字符串窗体是"
"用冒号分隔的数字列表。每个数字都指该级别的偏移量。因此，路径\"0\"是指根节点，"
"路径\"2：4\"是指第三个节点的第五个子节点。"

#: ../../source/treeview.txt:136
#, fuzzy
msgid ""
"Instances of :class:`Gtk.TreePath` can be accessed like lists, i.e. "
"``len(treepath)`` returns the depth of the item ``treepath`` is pointing to, "
"and ``treepath[i]`` returns the child's index on the *i*-th level."
msgstr ""
"：class：'Gtk.TreePath'的实例可以像列表一样进行访问，即\"len（树路径）\"返回"
"项目\"树路径\"指向的深度，而\"树路径\"返回子级 *i*-th 级别上的子级索引。"

#: ../../source/treeview.txt:142
#, fuzzy
msgid ""
"While there are several different models to choose from, there is only one "
"view widget to deal with. It works with either the list or the tree store. "
"Setting up a :class:`Gtk.TreeView` is not a difficult matter. It needs a :"
"class:`Gtk.TreeModel` to know where to retrieve its data from, either by "
"passing it to the :class:`Gtk.TreeView` constructor, or by calling :meth:"
"`Gtk.TreeView.set_model`."
msgstr ""
"虽然有几个不同的模型可供选择，但只有一个视图小部件要处理。它适用于列表或树存"
"储。设置 ：class：'Gtk.TreeView' 不是一个困难的事情。它需要一个 ："
"class：'Gtk.TreeModel'知道从哪儿检索数据，或者通过将其传递到 ：class：'Gtk."
"TreeView' 构造函数，或者通过调用 ：meth：'Gtk.TreeView.set_model'。"

#: ../../source/treeview.txt:153
#, fuzzy
msgid ""
"Once the :class:`Gtk.TreeView` widget has a model, it will need to know how "
"to display the model. It does this with columns and cell renderers."
msgstr ""
"一旦 ：class：'Gtk.TreeView' 小部件具有模型，它将需要知道如何显示模型。它使用"
"列和单元格渲染器进行此功能。"

#: ../../source/treeview.txt:156
#, fuzzy
msgid ""
"Cell renderers are used to draw the data in the tree model in a way. There "
"are a number of cell renderers that come with GTK+, for instance :class:`Gtk."
"CellRendererText`, :class:`Gtk.CellRendererPixbuf` and :class:`Gtk."
"CellRendererToggle`. In addition, it is relatively easy to write a custom "
"renderer yourself."
msgstr ""
"单元格渲染器用于以一种方式在树模型中绘制数据。GTK® 中有许多单元格渲染器，例"
"如 ：class：'Gtk.CellrendererText'，：类：'Gtk.CellrendererPixbuf'和 ："
"class：'Gtk.CellrendererToggle'。此外，自己编写自定义渲染器相对容易。"

#: ../../source/treeview.txt:162
#, fuzzy
msgid ""
"A :class:`Gtk.TreeViewColumn` is the object that :class:`Gtk.TreeView` uses "
"to organize the vertical columns in the tree view. It needs to know the name "
"of the column to label for the user, what type of cell renderer to use, and "
"which piece of data to retrieve from the model for a given row."
msgstr ""
"A ：class：'Gtk.TreeViewColumn' 是 ：class：'Gtk.TreeView' 用于组织树视图中的"
"垂直列的对象。它需要知道要为用户标记的列的名称、要使用的单元格呈现器类型以及"
"要从给定行的模型检索的数据段。"

#: ../../source/treeview.txt:173
#, fuzzy
msgid ""
"To render more than one model column in a view column, you need to create a :"
"class:`Gtk.TreeViewColumn` instance and use :meth:`Gtk.TreeViewColumn."
"pack_start` to add the model columns to it."
msgstr ""
"若要在视图列中呈现多个模型列，需要创建 ：class：'Gtk.TreeViewColumn'实例，并"
"使用：meth：'Gtk.TreeViewColumn.pack_start'将模型列添加到其中。"

#: ../../source/treeview.txt:193
msgid "The Selection"
msgstr "选择"

#: ../../source/treeview.txt:194
#, fuzzy
msgid ""
"Most applications will need to not only deal with displaying data, but also "
"receiving input events from users. To do this, simply get a reference to a "
"selection object and connect to the \"changed\" signal."
msgstr ""
"大多数应用程序不仅需要处理显示数据，还需要接收来自用户的输入事件。为此，只需"
"获取对选择对象的引用并连接到\"已更改\"信号。"

#: ../../source/treeview.txt:203
#, fuzzy
msgid "Then to retrieve data for the row selected:"
msgstr "然后检索所选行的数据："

#: ../../source/treeview.txt:212
#, fuzzy
msgid ""
"You can control what selections are allowed by calling :meth:`Gtk."
"TreeSelection.set_mode`. :meth:`Gtk.TreeSelection.get_selected` does not "
"work if the selection mode is set to :attr:`Gtk.SelectionMode.MULTIPLE`, "
"use :meth:`Gtk.TreeSelection.get_selected_rows` instead."
msgstr ""
"您可以通过调用 ：meth：'Gtk.TreeSelection.set_mode\"来控制允许的选择。：冰"
"毒：如果 Gtk.TreeSelection.get_selected选择模式设置为 ：attr：'Gtk.选择模式."
"多多'，则使用：meth：'Gtk.TreeSelection.get_selected_rows'。。"

#: ../../source/treeview.txt:219
msgid "Sorting"
msgstr "排序"

#: ../../source/treeview.txt:220
#, fuzzy
msgid ""
"Sorting is an important feature for tree views and is supported by the "
"standard tree models (:class:`Gtk.TreeStore` and :class:`Gtk.ListStore`), "
"which implement the :class:`Gtk.TreeSortable` interface."
msgstr ""
"排序是树视图的一个重要功能，由标准树模型（：类：'Gtk.TreeStore'和："
"class：'Gtk.listStore'）支持，它们实现 ：class：'Gtk.TreeSortable' 接口。"

#: ../../source/treeview.txt:223
msgid "Sorting by clicking on columns"
msgstr "通过单击列进行排序"

#: ../../source/treeview.txt:224
#, fuzzy
msgid ""
"A column of a :class:`Gtk.TreeView` can easily made sortable with a call to :"
"meth:`Gtk.TreeViewColumn.set_sort_column_id`. Afterwards the column can be "
"sorted by clicking on its header."
msgstr ""
"：类的列：'Gtk.TreeView'可以很容易地通过调用 ：meth：'Gtk.TreeViewColumn."
"set_sort_column_id\"。之后，可以通过单击其标题对列进行排序。"

#: ../../source/treeview.txt:227
#, fuzzy
msgid ""
"First we need a simple :class:`Gtk.TreeView` and a :class:`Gtk.ListStore` as "
"a model."
msgstr ""
"首先我们需要一个简单的 ：class：'Gtk.TreeView' 和 ：class：'Gtk.liststore'作"
"为模型。"

#: ../../source/treeview.txt:246
#, fuzzy
msgid ""
"The next step is to enable sorting. Note that the *column_id* (``0`` in the "
"example) refers to the column of the model and **not** to the TreeView's "
"column."
msgstr ""
"下一步是启用排序。请注意，*column_id* * （示例中的'0'） 是指模型的列，**不* "
"引用 TreeView 的列。"

#: ../../source/treeview.txt:253
msgid "Setting a custom sort function"
msgstr "设置自定义排序函数"

#: ../../source/treeview.txt:254
#, fuzzy
msgid ""
"It is also possible to set a custom comparison function in order to change "
"the sorting behaviour. As an example we will create a comparison function "
"that sorts case-sensitive. In the example above the sorted list looked like::"
msgstr ""
"还可以设置自定义比较函数以更改排序行为。例如，我们将创建一个比较函数，对大小"
"写敏感进行排序。在上面的示例中，排序列表看起来像："

#: ../../source/treeview.txt:267
#, fuzzy
msgid "The case-sensitive sorted list will look like::"
msgstr "对大小写敏感的排序列表将显示为："

#: ../../source/treeview.txt:278
#, fuzzy
msgid ""
"First of all a comparison function is needed. This function gets two rows "
"and has to return a negative integer if the first one should come before the "
"second one, zero if they are equal and a positive integer if the second one "
"should come before the second one."
msgstr ""
"首先需要一个比较函数。此函数得到两行，并且必须返回负整数（如果第一个整数应先"
"于第二行）;如果它们相等，则为零;如果第二行应先于第二行，则返回正整数。"

#: ../../source/treeview.txt:294
#, fuzzy
msgid ""
"Then the sort function has to be set by :meth:`Gtk.TreeSortable."
"set_sort_func`."
msgstr "然后排序函数必须设置为 ：meth：'Gtk.TreeSortable.set_sort_func'。"

#: ../../source/treeview.txt:301
msgid "Filtering"
msgstr "筛选"

#: ../../source/treeview.txt:302
#, fuzzy
msgid ""
"Unlike sorting, filtering is not handled by the two models we previously "
"saw, but by the :class:`Gtk.TreeModelFilter` class. This class, like :class:"
"`Gtk.TreeStore` and :class:`Gtk.ListStore`, is a :class:`Gtk.TreeModel`. It "
"acts as a layer between the \"real\" model (a :class:`Gtk.TreeStore` or a :"
"class:`Gtk.ListStore`), hiding some elements to the view. In practice, it "
"supplies the :class:`Gtk.TreeView` with a subset of the underlying model. "
"Instances of :class:`Gtk.TreeModelFilter` can be stacked one onto another, "
"to use multiple filters on the same model (in the same way you'd use \"AND\" "
"clauses in a SQL request). They can also be chained with :class:`Gtk."
"TreeModelSort` instances."
msgstr ""
"与排序不同，筛选不是由我们之前看到的两个模型处理，而是由 ：class：'Gtk."
"TreeModelFilter'类处理。此类，如 ：class：'Gtk.TreeStore' 和 ：class：'Gtk."
"listStore'，是 ：class：'Gtk.TreeModel'。它充当\"真实\"模型（a：class：'Gtk."
"TreeStore'或 ：class：'Gtk.ListStore'）之间的图层，将一些元素隐藏到视图中。实"
"际上，它提供 ：class：'Gtk.TreeView'，提供基础模型的子集。：class：'Gtk."
"TreeModelFilter' 的实例可以堆叠到另一个实例上，以在同一模型上使用多个筛选器"
"（就像在 SQL 请求中使用\"AND\"子句一样）。它们也可以与 ：class：'Gtk."
"TreeModelSort'实例链接。"

#: ../../source/treeview.txt:304
#, fuzzy
msgid ""
"You can create a new instance of a :class:`Gtk.TreeModelFilter` and give it "
"a model to filter, but the easiest way is to spawn it directly from the "
"filtered model, using the :meth:`Gtk.TreeModel.filter_new` method."
msgstr ""
"您可以创建 ：class：'Gtk.TreeModelFilter'的新实例，并给它一个模型进行筛选，但"
"最简单的方法是使用 ：meth：'Gtk.TreeModel.filter_new' 方法直接从筛选的模型生"
"成它。"

#: ../../source/treeview.txt:310
#, fuzzy
msgid ""
"In the same way the sorting function works, the :class:`Gtk.TreeModelFilter` "
"needs a \"visibility\" function, which, given a row from the underlying "
"model, will return a boolean indicating if this row should be filtered out "
"or not. It's set by :meth:`Gtk.TreeModelFilter.set_visible_func`:"
msgstr ""
"与排序函数的工作方式相同，排序函数：'Gtk.TreeModelFilter 需要一个\"可见性\"函"
"数，该函数给定基础模型中的一行，将返回一个布尔值，指示是否应筛选出此行。它设"
"置由：meth：'Gtk.TreeModelFilter.set_visible_func'："

#: ../../source/treeview.txt:316
#, fuzzy
msgid ""
"Let's look at a full example which uses the whole :class:`Gtk.ListStore` - :"
"class:`Gtk.TreeModelFilter` - :class:`Gtk.TreeModelFilter` - :class:`Gtk."
"TreeView` stack."
msgstr ""
"让我们看看使用整个 ：class：'Gtk.listStore' 的完整示例 - ：class：'Gtk."
"TreemodelFilter' - ：class：'Gtk.TreemodelFilter' - ：class：'Gtk.TreeView' "
"堆栈。"

#: ../../source/dialogs.txt:2
msgid "Dialogs"
msgstr "对话框"

#: ../../source/dialogs.txt:4
#, fuzzy
msgid ""
"Dialog windows are very similar to standard windows, and are used to provide "
"or retrieve information from the user. They are often used to provide a "
"preferences window, for example. The major difference a dialog has is some "
"prepacked widgets which layout the dialog automatically. From there, we can "
"simply add labels, buttons, check buttons, etc. Another big difference is "
"the handling of responses to control how the application should behave after "
"the dialog has been interacted with."
msgstr ""
"对话框窗口与标准窗口非常相似，用于提供或检索用户的信息。例如，它们通常用于提"
"供首选项窗口。对话框的主要区别是一些预装小部件，它们会自动布局对话框。从那"
"里，我们可以简单地添加标签，按钮，检查按钮等。另一个大的区别是处理响应来控制"
"应用程序在与对话框交互后应如何行为。"

#: ../../source/dialogs.txt:12
#, fuzzy
msgid ""
"There are several derived Dialog classes which you might find useful. :class:"
"`Gtk.MessageDialog` is used for most simple notifications. But at other "
"times you might need to derive your own dialog class to provide more complex "
"functionality."
msgstr ""
"有几个派生的对话框类，您可能会发现这些类很有用。：类：\"Gtk.MessageDialog\"用"
"于最简单的通知。但在其他时候，您可能需要派生自己的对话框类以提供更复杂的功"
"能。"

#: ../../source/dialogs.txt:18
msgid "Custom Dialogs"
msgstr "自定义对话框"

#: ../../source/dialogs.txt:20
#, fuzzy
msgid ""
"To pack widgets into a custom dialog, you should pack them into the :class:"
"`Gtk.Box`, available via :meth:`Gtk.Dialog.get_content_area`. To just add a :"
"class:`Gtk.Button` to the bottom of the dialog, you could use the :meth:`Gtk."
"Dialog.add_button` method."
msgstr ""
"要将小部件打包到自定义对话框中，应将它们打包到 ：class：'Gtk.Box'中，可通过 "
"：meth：'Gtk.Dialog.get_content_area\"。若要在对话框的底部添加 ：class：'Gtk."
"button'，可以使用 ：meth：'Gtk.Dialog.add_button\" 方法。"

#: ../../source/dialogs.txt:25
#, fuzzy
msgid ""
"A 'modal' dialog (that is, one which freezes the rest of the application "
"from user input), can be created by calling :class:`Gtk.Dialog.set_modal` on "
"the dialog or set the ``flags`` argument of the :class:`Gtk.Dialog` "
"constructor to include the :attr:`Gtk.DialogFlags.MODAL` flag."
msgstr ""
"可以通过在对话框上调用 ：class：'Gtk.Dialog.set_modal\"创建\"模式\"对话框（即"
"从用户输入冻结应用程序的其余部分的对话框），也可以将 ：class：'Gtk.Dialog' 构"
"造函数的\"标志\"参数设置为包含 ：attr：'Gtk.DialogFlags.MODAL'标志。"

#: ../../source/dialogs.txt:30
#, fuzzy
msgid ""
"Clicking a button will emit a signal called \"response\". If you want to "
"block waiting for a dialog to return before returning control flow to your "
"code, you can call :meth:`Gtk.Dialog.run`. This method returns an int which "
"may be a value from the :class:`Gtk.ResponseType` or it could be the custom "
"response value that you specified in the :class:`Gtk.Dialog` constructor or :"
"meth:`Gtk.Dialog.add_button`."
msgstr ""
"单击按钮将发出称为\"响应\"的信号。如果要阻止等待对话框返回，然后再将控制流返"
"回到代码，可以调用 ：meth：'Gtk.Dialog.run'。此方法返回一个 int，该 int 可能"
"是来自 ：class：'Gtk.响应类型'的值，也可以是您指定的自定义响应值：'Gtk."
"Dialog' 构造函数或 ：meth：'Gtk.Dialog.add_button'。"

#: ../../source/dialogs.txt:36
#, fuzzy
msgid ""
"Finally, there are two ways to remove a dialog. The :meth:`Gtk.Widget.hide` "
"method removes the dialog from view, however keeps it stored in memory. This "
"is useful to prevent having to construct the dialog again if it needs to be "
"accessed at a later time. Alternatively, the :meth:`Gtk.Widget.destroy` "
"method can be used to delete the dialog from memory once it is no longer "
"needed. It should be noted that if the dialog needs to be accessed after it "
"has been destroyed, it will need to be constructed again otherwise the "
"dialog window will be empty."
msgstr ""
"最后，有两种方法可以删除对话框。：meth：'Gtk.Widget.hide' 方法从视图中删除对"
"话框，但将其存储在内存中。如果以后需要访问对话框，这非常有用，可以防止再次构"
"造对话框。或者，：meth：'Gtk.Widget.销毁'方法可用于在不再需要对话框时从内存中"
"删除对话框。应该注意的是，如果该对话框在销毁后需要访问，则需要再次构造该对话"
"框窗口，否则对话框窗口将为空。"

#: ../../source/dialogs.txt:53
msgid "MessageDialog"
msgstr "消息诊断"

#: ../../source/dialogs.txt:55
#, fuzzy
msgid ""
":class:`Gtk.MessageDialog` is a convenience class, used to create simple, "
"standard message dialogs, with a message, an icon, and buttons for user "
"response You can specify the type of message and the text in the :class:`Gtk."
"MessageDialog` constructor, as well as specifying standard buttons."
msgstr ""
"：类：'Gtk.MessageDialog' 是一个方便类，用于创建简单的标准消息对话框，带有消"
"息、图标和用户响应按钮，您可以在 ：class：'Gtk.MessageDialog' 构造函数中指定"
"消息类型和文本，以及指定标准按钮。"

#: ../../source/dialogs.txt:60
#, fuzzy
msgid ""
"In some dialogs which require some further explanation of what has happened, "
"a secondary text can be added. In this case, the primary message entered "
"when creating the message dialog is made bigger and set to bold text. The "
"secondary message can be set by calling :meth:`Gtk.MessageDialog."
"format_secondary_text`."
msgstr ""
"在一些需要进一步解释所发生内容的对话框中，可以添加辅助文本。在这种情况下，创"
"建消息对话框时输入的主要消息将变大并设置为粗体文本。辅助消息可以通过调用 ："
"meth：'Gtk.MessageDialog.format_secondary_text\" 来设置。"

#: ../../source/dialogs.txt:74
msgid "FileChooserDialog"
msgstr "文件选择"

#: ../../source/dialogs.txt:76
#, fuzzy
msgid ""
"The :class:`Gtk.FileChooserDialog` is suitable for use with \"File/Open\" or "
"\"File/Save\" menu items. You can use all of the :class:`Gtk.FileChooser` "
"methods on the file chooser dialog as well as those for :class:`Gtk.Dialog`."
msgstr ""
"：class：'Gtk.FileChooserDialog' 适合与\"文件/打开\"或\"文件/保存\"菜单项一起"
"使用。您可以在文件选择器对话框上使用所有 ：class：'Gtk.FileChooser'方法，以"
"及 ：class：'Gtk.Dialog'的方法。"

#: ../../source/dialogs.txt:80
#, fuzzy
msgid ""
"When creating a :class:`Gtk.FileChooserDialog` you have to define the "
"dialog's purpose:"
msgstr "创建 ：class：'Gtk.FileChooserDialog 时，您必须定义对话框的目的："

#: ../../source/dialogs.txt:83
#, fuzzy
msgid ""
"To select a file for opening, as for a File/Open command, use :attr:`Gtk."
"FileChooserAction.OPEN`"
msgstr ""
"要选择要打开的文件，如文件/打开命令，请使用 ：attr：'Gtk.FileChooserAction."
"OPEN'"

#: ../../source/dialogs.txt:85
#, fuzzy
msgid ""
"To save a file for the first time, as for a File/Save command, use :attr:"
"`Gtk.FileChooserAction.SAVE`, and suggest a name such as \"Untitled\" with :"
"meth:`Gtk.FileChooser.set_current_name`."
msgstr ""
"若要首次保存文件，如文件/保存命令，请使用 ：attr：'Gtk.FileChooserAction."
"SAVE'，并建议一个名称，如名称，如：meth：'Gtk.FileChooser.set_current_name'。"

#: ../../source/dialogs.txt:88
#, fuzzy
msgid ""
"To save a file under a different name, as for a File/Save As command, use :"
"attr:`Gtk.FileChooserAction.SAVE`, and set the existing filename with :meth:"
"`Gtk.FileChooser.set_filename`."
msgstr ""
"若要以其他名称保存文件，如文件/保存为命令，请使用 ：attr：'Gtk."
"FileChooserAction.SAVE'，并使用 ：meth：'Gtk.FileChooser.set_filename'设置现"
"有文件名。"

#: ../../source/dialogs.txt:91
#, fuzzy
msgid ""
"To choose a folder instead of a file, use :attr:`Gtk.FileChooserAction."
"SELECT_FOLDER`."
msgstr ""
"要选择文件夹而不是文件，请使用 ：attr：'Gtk.FileChooserAction."
"SELECT_FOLDER'。"

#: ../../source/dialogs.txt:93
#, fuzzy
msgid ""
":class:`Gtk.FileChooserDialog` inherits from :class:`Gtk.Dialog`, so buttons "
"have response IDs such as :attr:`Gtk.ResponseType.ACCEPT` and :attr:`Gtk."
"ResponseType.CANCEL` which can be specified in the :class:`Gtk."
"FileChooserDialog` constructor. In contrast to :class:`Gtk.Dialog`, you can "
"not use custom response codes with :class:`Gtk.FileChooserDialog`. It "
"expects that at least one button will have of the following response IDs:"
msgstr ""
"：类：'Gtk.FileChooserDialog'继承自：class：'Gtk.Dialog'，因此按钮具有响应 "
"ID，例如 ：attr：'Gtk.响应类型.接受'和 ：attr：'Gtk.响应类型.CANCEL'，可以在 "
"：class：'Gtk.FileChooserDialog' 构造函数中指定。与 ：class：'Gtk.Dialog'相"
"比，不能使用自定义响应代码与 ：class：'Gtk.FileChooserDialog'。它预计至少有一"
"个按钮具有以下响应 ID："

#: ../../source/dialogs.txt:100
msgid ":attr:`Gtk.ResponseType.ACCEPT`"
msgstr ":attr:`Gtk.ResponseType.ACCEPT`"

#: ../../source/dialogs.txt:101
msgid ":attr:`Gtk.ResponseType.OK`"
msgstr ":attr:`Gtk.ResponseType.OK`"

#: ../../source/dialogs.txt:102
msgid ":attr:`Gtk.ResponseType.YES`"
msgstr ":attr:`Gtk.ResponseType.YES`"

#: ../../source/dialogs.txt:103
msgid ":attr:`Gtk.ResponseType.APPLY`"
msgstr ":attr:`Gtk.ResponseType.APPLY`"

#: ../../source/dialogs.txt:105
#, fuzzy
msgid ""
"When the user is finished selecting files, your program can get the selected "
"names either as filenames (:meth:`Gtk.FileChooser.get_filename`) or as URIs "
"(:meth:`Gtk.FileChooser.get_uri`)."
msgstr ""
"当用户完成选择文件后，程序可以获取所选名称作为文件名（：meth：'Gtk."
"FileChooser.get_filename'）或 1001 年（：meth：'Gtk.FileChooser.get_uri'）。"

#: ../../source/dialogs.txt:109
#, fuzzy
msgid ""
"By default, :class:`Gtk.FileChooser` only allows a single file to be "
"selected at a time. To enable multiple files to be selected, use :meth:`Gtk."
"FileChooser.set_select_multiple`. Retrieving a list of selected files is "
"possible with either :meth:`Gtk.FileChooser.get_filenames` or :meth:`Gtk."
"FileChooser.get_uris`."
msgstr ""
"默认情况下，：类：'Gtk.FileChooser'一次只允许选择一个文件。要选择多个文件，请"
"使用 ：meth：'Gtk.FileChooser.set_select_multiple'。使用 ：meth：'Gtk."
"FileChooser.get_filenames'或：meth：'Gtk.FileChooser.get_uris'来检索所选文件"
"的列表是可能的。"

#: ../../source/dialogs.txt:115
#, fuzzy
msgid ""
":class:`Gtk.FileChooser` also supports a variety of options which make the "
"files and folders more configurable and accessible."
msgstr ""
"：类：'Gtk.FileChooser' 还支持各种选项，使文件和文件夹更可配置和可访问。"

#: ../../source/dialogs.txt:118
#, fuzzy
msgid ""
":meth:`Gtk.FileChooser.set_local_only`: Only local files can be selected."
msgstr "：meth：Gtk.FileChooser.set_local_only\"：只能选择本地文件。"

#: ../../source/dialogs.txt:119
#, fuzzy
msgid ""
":meth:`Gtk.FileChooser.show_hidden`: Hidden files and folders are displayed."
msgstr "：meth：Gtk.FileChooser.show_hidden\"：显示隐藏的文件和文件夹。"

#: ../../source/dialogs.txt:120
#, fuzzy
msgid ""
":meth:`Gtk.FileChooser.set_do_overwrite_confirmation`: If the file chooser "
"was configured in :attr:`Gtk.FileChooserAction.SAVE` mode, it will present a "
"confirmation dialog if the user types a file name that already exists."
msgstr ""
"：meth：'Gtk.FileChooser.set_do_overwrite_confirmation'：如果文件选择器配置"
"为 ：attr：'Gtk.FileChooserAction.SAVE'模式，如果用户输入已存在的文件名，它将"
"显示一个确认对话框。"

#: ../../source/dialogs.txt:124
#, fuzzy
msgid ""
"Furthermore, you can specify which kind of files are displayed by creating :"
"class:`Gtk.FileFilter` objects and calling :meth:`Gtk.FileChooser."
"add_filter`. The user can then select one of the added filters from a combo "
"box at the bottom of the file chooser."
msgstr ""
"此外，您可以通过创建 ：class：'Gtk.FileFilter'对象和调用：meth：'Gtk."
"FileChooser.add_filter来指定显示的文件类型。然后，用户可以从文件选择器底部的"
"组合框中选择添加的筛选器之一。"

#: ../../source/install.txt:4
msgid "Installation"
msgstr "安装"

#: ../../source/install.txt:5
#, fuzzy
msgid ""
"The first step before we start with actual coding consists of setting up "
"`PyGObject`_ and its dependencies. PyGObject is a Python module that enables "
"developers to access GObject-based libraries such as GTK+ within Python. It "
"exclusively supports GTK+ version 3 or later."
msgstr ""
"在开始实际编码之前的第一步是设置\"PyGObject\"_及其依赖关系。PyGObject 是一个 "
"Python 模块，它使开发人员能够访问 Python 中基于 GObject 的库，如 GTK®。它专门"
"支持 GTK® 版本 3 或更晚版本。"

#: ../../source/install.txt:12
msgid "Dependencies"
msgstr "依赖"

#: ../../source/install.txt:14
msgid "GTK+3"
msgstr "GTK+3"

#: ../../source/install.txt:16
msgid "Python 2 (2.6 or later) or Python 3 (3.1 or later)"
msgstr "Python 2 （2.6 或更新） 或 Python 3 （3.1 或更新）"

#: ../../source/install.txt:18
msgid "gobject-introspection"
msgstr "gobject 自测"

#: ../../source/install.txt:21
msgid "Prebuilt Packages"
msgstr "预构建包"

#: ../../source/install.txt:22
#, fuzzy
msgid ""
"Recent versions of PyGObject and its dependencies are packaged by nearly all "
"major Linux distributions. So, if you use Linux, you can probably get "
"started by installing the package from the official repository for your "
"distribution."
msgstr ""
"PyGObject 及其依赖项的最新版本几乎由所有主要 Linux 发行版打包。因此，如果您使"
"用 Linux，则可能从官方存储库中安装包来分发。"

#: ../../source/install.txt:28
msgid "Installing From Source"
msgstr "从源安装"

#: ../../source/install.txt:29
#, fuzzy
msgid ""
"The easiest way to install PyGObject from source is using `JHBuild`_. It is "
"designed to easily build source packages and discover what dependencies need "
"to be build and in what order. To setup JHBuild, please follow the `JHBuild "
"manual`_."
msgstr ""
"从源安装 PyGObject 的最简单方法是使用\"JHBuild\"_ 。它旨在轻松生成源包，并发"
"现需要构建哪些依赖项以及按什么顺序构建。要设置 JHBuild，请按照\"JHBuild 手册"
"\"_。"

#: ../../source/install.txt:33
#, fuzzy
msgid ""
"Once you have installed JHBuild successfully, download the latest "
"configuration from [#]_. Copy files with the suffix `.modules` to JHBuild's "
"module directory and the file `sample-tarball.jhbuildrc` to `~/.jhbuildrc`."
msgstr ""
"成功安装 JHBuild 后，请从 {#}_下载最新配置。将后缀为\".模块\"的文件复制到 "
"JHBuild 的模块目录，将文件\"样本 tarball.jhbuildrc\"复制到\"\\/.jhbuildrc\"。"

#: ../../source/install.txt:37
#, fuzzy
msgid ""
"If you have not done it before, verify that your build environment is setup "
"correctly by running::"
msgstr "如果以前未执行过，请通过运行验证生成环境设置是否正确："

#: ../../source/install.txt:42
#, fuzzy
msgid ""
"It will print any applications and libraries that are currently missing on "
"your system but required for building. You should install those using your "
"distribution's package repository. A list of `package names <https://wiki."
"gnome.org/action/show/Projects/Jhbuild/Dependencies>`_ for different "
"distributions is maintained on the GNOME wiki. Run the command above again "
"to ensure the required tools are present."
msgstr ""
"它将打印系统中当前缺少但需要构建的任何应用程序和库。您应该使用分发的包存储库"
"安装这些内容。GNOME wiki 上保留了不同分布的\"包名称<https：//wiki.gnome.org/"
"行动/显示/项目/Jhbuild/依赖项>\"_列表。再次运行上述命令，以确保存在所需的工"
"具。"

#: ../../source/install.txt:48
#, fuzzy
msgid ""
"Executing the following command will build PyGObject and all its "
"dependencies::"
msgstr "执行以下命令将生成 PyGObject 及其所有依赖项："

#: ../../source/install.txt:52
#, fuzzy
msgid "Finally, you might want to install GTK+ from source as well::"
msgstr "最后，您可能还希望从源安装 GTK+："

#: ../../source/install.txt:56
#, fuzzy
msgid "To start a shell with the same environment as used by JHBuild, run::"
msgstr "若要启动与 JHBuild 使用的环境相同的 shell，请运行："

#: ../../source/install.txt:64
#, fuzzy
msgid "https://download.gnome.org/teams/releng/"
msgstr "https://download.gnome.org/teams/releng/"

#: ../../source/popover.txt:2
msgid "Popovers"
msgstr "弹窗"

#: ../../source/popover.txt:4
#, fuzzy
msgid ""
"The :class:`Gtk.Popover` is a seperate window used for displaying additional "
"information and are often used as a part of button menus and context menus. "
"Their uses are similar to those of dialog windows with the advantage of "
"being less disruptive and having a connection with the widget the popover is "
"pointing to. Popovers have are visually connected to a related widget with a "
"small triangle."
msgstr ""
"：class：'Gtk.Popover' 是一个单独的窗口，用于显示其他信息，通常用作按钮菜单和"
"上下文菜单的一部分。它们的用途与对话框窗口的用途类似，其优点是减少中断性，并"
"且与弹出指向的小部件有联系。弹出式图像具有视觉上连接到具有小三角形的相关小部"
"件。"

#: ../../source/popover.txt:10
#, fuzzy
msgid ""
"A Popover can be created with :class:`Gtk.Popover`; for opening the popover "
"use :meth:`Gtk.Widget.show_all`."
msgstr ""
"可以使用 ：class 创建 Popover：'Gtk.Popover';用于打开弹出使用：冰毒：'Gtk."
"Widget.show_all'。"

#: ../../source/popover.txt:14
msgid "Custom Popover"
msgstr "自定义弹出"

#: ../../source/popover.txt:16
#, fuzzy
msgid "A widget can be added to a popover using the :meth:`Gtk.Container.add`."
msgstr "可以使用 ：meth：'Gtk.容器.add'将小部件添加到弹出。"

#: ../../source/popover.txt:27
msgid "Menu Popover"
msgstr "菜单弹出"

#: ../../source/popover.txt:29
#, fuzzy
msgid ""
"A popover can be created from a :class:`Gio.MenuModel` using :meth:`Gtk."
"Popover.new_from_model` and can be changed after creation with :meth:`Gtk."
"Popover.bind_model`."
msgstr ""
"可以从 ：class：'Gio.MenuModel 使用 ：meth：'Gtk.Popover.new_from_model\"创建"
"弹出，在创建后可以使用：meth：'Gtk.Popover.bind_model\"。"

#: ../../source/popover.txt:41 ../../source/application.txt:69
msgid "See Also"
msgstr "参见"

#: ../../source/popover.txt:43
#, fuzzy
msgid "https://developer.gnome.org/hig/stable/popovers.html.en"
msgstr "https://developer.gnome.org/hig/stable/popovers.html.en"

#: ../../source/drag_and_drop.txt:2
msgid "Drag and Drop"
msgstr "拖放"

#: ../../source/drag_and_drop.txt:4
#, fuzzy
msgid ""
"Versions of PyGObject < 3.0.3 contain a bug which does not allow drag and "
"drop to function correctly. Therefore a version of PyGObject >= 3.0.3 is "
"required for the following examples to work."
msgstr ""
"PyGObject < 3.0.3 的版本包含一个不允许拖放正常运行的错误。因此，PyGObject >= "
"3.0.3 的版本需要执行以下示例才能正常工作。"

#: ../../source/drag_and_drop.txt:8
#, fuzzy
msgid ""
"Setting up drag and drop between widgets consists of selecting a drag source "
"(the widget which the user starts the drag from) with the :meth:`Gtk.Widget."
"drag_source_set` method, selecting a drag destination (the widget which the "
"user drops onto) with the :meth:`Gtk.Widget.drag_dest_set` method and then "
"handling the relevant signals on both widgets."
msgstr ""
"在小部件之间设置拖放包括选择一个拖动源（用户启动拖动的小部件）使用："
"meth：'Gtk.Widget.drag_source_set'方法，选择一个拖动目标（用户丢弃到的小部"
"件）使用：meth：'Gtk.Widget.drag_dest_set'方法，然后处理两个小部件上的相关信"
"号。"

#: ../../source/drag_and_drop.txt:14
#, fuzzy
msgid ""
"Instead of using :meth:`Gtk.Widget.drag_source_set` and :meth:`Gtk.Widget."
"drag_dest_set` some specialised widgets require the use of specific "
"functions (such as :class:`Gtk.TreeView` and :class:`Gtk.IconView`)."
msgstr ""
"而不是使用：meth：'Gtk.Widget.drag_source_set'和：Gtk.Widget.drag_dest_set'一"
"些专门的小部件需要使用特定的功能（如：'类：'Gtk.TreeView'和：类：'Gtk."
"IconView'）。"

#: ../../source/drag_and_drop.txt:18
#, fuzzy
msgid ""
"A basic drag and drop only requires the source to connect to the \"drag-data-"
"get\" signal and the destination to connect to the \"drag-data-received\" "
"signal. More complex things such as specific drop areas and custom drag "
"icons will require you to connect to :ref:`additional signals <drag-"
"signals>` and interact with the :class:`Gdk.DragContext` object it supplies."
msgstr ""
"基本拖放只需要源连接到\"拖动数据获取\"信号，目标连接到\"拖动数据接收\"信号。"
"更复杂的事情，如特定的拖放区域和自定义拖动图标将要求您连接到 ：ref：'附加 "
"<drag-signals>信号'，并与 ：class：'Gdk.DragContext' 对象进行交互。</drag-"
"signals>"

#: ../../source/drag_and_drop.txt:24
#, fuzzy
msgid ""
"In order to transfer data between the source and destination, you must "
"interact with the :class:`Gtk.SelectionData` variable supplied in the :ref:`"
"\"drag-data-get\" <drag-signals>` and :ref:`\"drag-data-received\" <drag-"
"signals>` signals using the :class:`Gtk.SelectionData` get and set methods."
msgstr ""
"为了在源和目标之间传输数据，您必须与 ：class：'Gtk.SelectionData'变量进行交"
"互，该变量在 ：ref：\"拖动数据获取\"和<drag-signals>：ref：\"拖动数据接收\"信"
"号使用<drag-signals>：class：'Gtk.SelectionData'获取并设置方法。</drag-"
"signals> </drag-signals>"

#: ../../source/drag_and_drop.txt:30
msgid "Target Entries"
msgstr "目标条目"

#: ../../source/drag_and_drop.txt:31
#, fuzzy
msgid ""
"To allow the drag source and destination to know what data they are "
"receiving and sending, a common list of :class:`Gtk.TargetEntry's <Gtk."
"TargetEntry>` are required. A :class:`Gtk.TargetEntry` describes a piece of "
"data that will be sent by the drag source and received by the drag "
"destination."
msgstr ""
"为了让拖动源和目标知道他们正在接收和发送哪些数据，需要一个常见的列表：'Gtk."
"TargetEntry 的 <Gtk.TargetEntry>\"。A ：class：'Gtk.TargetEntry' 描述了将由拖"
"动源发送并由拖动目标接收的数据段。"

#: ../../source/drag_and_drop.txt:36
#, fuzzy
msgid ""
"There are two ways of adding :class:`Gtk.TargetEntry's <Gtk.TargetEntry>` to "
"a source and destination. If the drag and drop is simple and each target "
"entry is of a different type, you can use the group of methods :meth:"
"`mentioned here <Gtk.Widget.drag_source_add_text_targets>`."
msgstr ""
"有两种方法可以将 ：class：'Gtk.TargetEntry 的 <Gtk.TargetEntry>\"添加到源和目"
"的地。如果拖放很简单，并且每个目标条目都是不同类型的，您可以使用方法组："
"meth：'此处提到的<Gtk.Widget.drag_source_add_text_targets>'。"

#: ../../source/drag_and_drop.txt:41
#, fuzzy
msgid ""
"If you require more than one type of data or wish to do more complex things "
"with the data, you will need to create the :class:`Gtk.TargetEntry's <Gtk."
"TargetEntry>` using the :meth:`Gtk.TargetEntry.new` method."
msgstr ""
"如果您需要多种类型的数据或希望对数据执行更复杂的操作，则需要使用 ："
"meth：'Gtk.TargetEntry 的 <Gtk.TargetEntry>\"方法创建 ：class：'Gtk."
"TargetEntry.new'。"

#: ../../source/drag_and_drop.txt:48
msgid "Drag Source Signals"
msgstr "拖动源信号"

#: ../../source/drag_and_drop.txt:50 ../../source/drag_and_drop.txt:64
msgid "Name"
msgstr "名称"

#: ../../source/drag_and_drop.txt:50 ../../source/drag_and_drop.txt:64
msgid "When it is emitted"
msgstr "当它被发射时"

#: ../../source/drag_and_drop.txt:50 ../../source/drag_and_drop.txt:64
msgid "Common Purpose"
msgstr "共同目的"

#: ../../source/drag_and_drop.txt:52
msgid "drag-begin"
msgstr "拖动开始"

#: ../../source/drag_and_drop.txt:52
msgid "User starts a drag"
msgstr "用户启动拖动"

#: ../../source/drag_and_drop.txt:52
msgid "Set-up drag icon"
msgstr "设置拖动图标"

#: ../../source/drag_and_drop.txt:54
msgid "drag-data-get"
msgstr "拖动数据获取"

#: ../../source/drag_and_drop.txt:54
msgid "When drag data is requested by the destination"
msgstr "当目标请求拖动数据时"

#: ../../source/drag_and_drop.txt:54 ../../source/drag_and_drop.txt:70
msgid "Transfer drag data from source to destination"
msgstr "将拖动数据从源传输到目标"

#: ../../source/drag_and_drop.txt:56
msgid "drag-data-delete"
msgstr "拖动数据删除"

#: ../../source/drag_and_drop.txt:56
msgid "When a drag with the action Gdk.DragAction.MOVE is completed"
msgstr "当使用操作 Gdk.DragAction.MOVE 的拖动完成时"

#: ../../source/drag_and_drop.txt:56
msgid "Delete data from the source to complete the 'move'"
msgstr "从源中删除数据以完成 \"移动\""

#: ../../source/drag_and_drop.txt:58
msgid "drag-end"
msgstr "拖动端"

#: ../../source/drag_and_drop.txt:58
msgid "When the drag is complete"
msgstr "拖动完成后"

#: ../../source/drag_and_drop.txt:58
msgid "Undo anything done in drag-begin"
msgstr "撤消拖动开始中完成的工作"

#: ../../source/drag_and_drop.txt:62
msgid "Drag Destination Signals"
msgstr "拖动目标信号"

#: ../../source/drag_and_drop.txt:66
msgid "drag-motion"
msgstr "拖动运动"

#: ../../source/drag_and_drop.txt:66
msgid "Drag icon moves over a drop area"
msgstr "拖动图标在拖放区域上移动"

#: ../../source/drag_and_drop.txt:66 ../../source/drag_and_drop.txt:68
msgid "Allow only certain areas to be dropped onto"
msgstr "只允许将特定区域拖放到"

#: ../../source/drag_and_drop.txt:68
msgid "drag-drop"
msgstr "拖放"

#: ../../source/drag_and_drop.txt:68
msgid "Icon is dropped onto a drag area"
msgstr "图标被拖放到拖动区域"

#: ../../source/drag_and_drop.txt:70
msgid "drag-data-received"
msgstr "接收的拖动数据"

#: ../../source/drag_and_drop.txt:70
#, fuzzy
msgid "When drag data is received by the destination"
msgstr "当目标接收拖动数据时"

#: ../../source/application.txt:4
msgid "Application"
msgstr "应用程序"

#: ../../source/application.txt:6
#, fuzzy
msgid ""
":class:`Gtk.Application` encompasses many repetitive tasks that a modern "
"application needs such as handling multiple instances, D-Bus activation, "
"opening files, command line parsing, startup/shutdown, menu management, "
"window management, and more."
msgstr ""
"：类：\"Gtk.应用程序\"包含现代应用程序需要的许多重复性任务，例如处理多个实"
"例、D-Bus 激活、打开文件、命令行分析、启动/关闭、菜单管理、窗口管理等。"

#: ../../source/application.txt:14
#, fuzzy
msgid ""
":class:`Gio.Action` is a way to expose any single task your application or "
"widget does by a name. These actions can be disabled/enabled at runtime and "
"they can either be activated or have a state changed (if they contain state)."
msgstr ""
"：类：\"Gio.Action\"是一种通过名称公开应用程序或小部件执行的任何单个任务的方"
"法。这些操作可以在运行时禁用/启用，并且可以激活或更改状态（如果它们包含状"
"态）。"

#: ../../source/application.txt:18
#, fuzzy
msgid ""
"The reason to use actions is to separate out the logic from the UI. For "
"example this allows using a menubar on OSX and a gear menu on GNOME both "
"simply referencing the name of an action. The main implementation of this "
"you will be using is :class:`Gio.SimpleAction` which will be demonstrated "
"later."
msgstr ""
"使用操作的原因是将逻辑与 UI 分离。例如，这允许在 OSX 上使用菜单栏，在 GNOME "
"上使用齿轮菜单，这两者都只是引用操作的名称。您将使用的主要实现是 ："
"class：'Gio.SimpleAction'，稍后将演示。"

#: ../../source/application.txt:23
#, fuzzy
msgid ""
"Many classes such as :class:`Gio.MenuItem` and :class:`Gtk.ModelButton` "
"support properties to set an action name."
msgstr ""
"许多类，如 ：class：'Gio.MenuItem' 和 ：class：'Gtk.ModelButton'支持属性来设"
"置操作名称。"

#: ../../source/application.txt:26
#, fuzzy
msgid ""
"These actions can be grouped together into a :class:`Gio.ActionGroup` and "
"when these groups are added to a widget with :meth:`Gtk.Widget."
"insert_action_group()` they will gain a prefix. Such as \"win\" when added "
"to a :class:`Gtk.ApplicationWindow`. You will use the full action name when "
"referencing it such as \"app.about\" but when you create the action it will "
"just be \"about\" until added to the application."
msgstr ""
"这些操作可以组合到：class：'Gio.ActionGroup'中，当这些组添加到一个小部件中"
"时，这些操作将用 ：meth：'Gtk.Widget.insert_action_group）'，它们将获得前缀。"
"如\"赢\"时添加到：类：'Gtk.应用程序窗口'。引用完整操作名称（如\"app.about\"）"
"时，将使用完整操作名称，但创建操作时，它只会\"约\"，直到添加到应用程序。"

#: ../../source/application.txt:32
#, fuzzy
msgid ""
"You can also very easily make keybindings for actions by setting the `accel` "
"property in the :class:`Gio.Menu` file or by using :meth:`Gtk.Application."
"add_accelerator()`."
msgstr ""
"您还可以通过设置 ：class 中的\"accel\"属性或使用：meth：'Gtk.Application."
"add_accelerator）来非常轻松地为操作进行键绑定。"

#: ../../source/application.txt:38
#, fuzzy
msgid ""
"Your menus should be defined in XML using :class:`Gio.Menu` and would "
"reference the previously mentioned actions you defined. :class:`Gtk."
"Application` allows you to set a menu either via :meth:`Gtk.Application."
"set_app_menu()` or :meth:`Gtk.Application.set_menubar()`. If you make use "
"of :class:`Gio.Resource` this can automatically use the correct menu based "
"on platform, otherwise you can set them manually. A detailed example is "
"shown below."
msgstr ""
"您的菜单应在 XML 中使用 ：class：'Gio.Menu' 进行定义，并引用前面提到的操"
"作。：类：'Gtk.应用程序'允许您设置菜单通过：meth：'Gtk.Application."
"set_app_menu）'或：meth：'Gtk.Application.set_menubar（）'。如果使用 ："
"class：'Gio.Resource'，可以基于平台自动使用正确的菜单，否则您可以手动设置它"
"们。下面显示了一个详细示例。"

#: ../../source/application.txt:46
msgid "Command Line"
msgstr "命令行"

#: ../../source/application.txt:48
#, fuzzy
msgid ""
"When creating your application it takes a flag property of :class:`Gio."
"ApplicationFlags`. Using this you can let it handle everything itself or "
"have more custom behavior."
msgstr ""
"创建应用程序时，它采用 ：class：'Gio.应用程序标志'的标记属性。使用此选项可以"
"让它处理所有内容本身或具有更多自定义行为。"

#: ../../source/application.txt:51
#, fuzzy
msgid ""
"You can use `HANDLES_COMMAND_LINE` to allow custom behavior in :meth:`Gio."
"Application.do_command_line()`. In combination with :meth:`Gio.Application."
"add_main_option()` to add custom options."
msgstr ""
"您可以使用\"HANDLES_COMMAND_LINE\"来允许自定义行为在 ：meth：'Gio."
"Application.do_command_line）中。结合 ：meth：'Gio.Application."
"add_main_option）'添加自定义选项。"

#: ../../source/application.txt:54
#, fuzzy
msgid ""
"Using `HANDLES_OPEN` will do the work of simply taking file arguments for "
"you and let you handle it in :meth:`Gio.Application.do_open()`."
msgstr ""
"使用\"HANDLES_OPEN\"将做简单地为你采取文件参数的工作，让你处理它在："
"meth：'Gio.Application.do_open）'。"

#: ../../source/application.txt:57
#, fuzzy
msgid ""
"If your application is already open these will all be sent to the existing "
"instance unless you use `NON_UNIQUE` to allow multiple instances."
msgstr ""
"如果应用程序已打开，这些都将发送到现有实例，除非您使用\"NON_UNIQUE\"来允许多"
"个实例。"

#: ../../source/application.txt:71
msgid "https://wiki.gnome.org/HowDoI/GtkApplication"
msgstr "https://wiki.gnome.org/HowDoI/GtkApplication"

#: ../../source/application.txt:72
msgid "https://wiki.gnome.org/HowDoI/GAction"
msgstr "https://wiki.gnome.org/HowDoI/GAction"

#: ../../source/application.txt:73
msgid "https://wiki.gnome.org/HowDoI/ApplicationMenu"
msgstr "https://wiki.gnome.org/HowDoI/ApplicationMenu"

#: ../../source/application.txt:74
msgid "https://wiki.gnome.org/HowDoI/GMenu"
msgstr "https://wiki.gnome.org/HowDoI/GMenu"

#: ../../source/introduction.txt:4
msgid "Getting Started"
msgstr "入门"

#: ../../source/introduction.txt:7
msgid "Simple Example"
msgstr "简单示例"

#: ../../source/introduction.txt:9
#, fuzzy
msgid ""
"To start with our tutorial we create the simplest program possible. This "
"program will create an empty 200 x 200 pixel window."
msgstr ""
"首先，我们的教程，我们创建最简单的程序可能。此程序将创建一个空的 200 x 200 像"
"素窗口。"

#: ../../source/introduction.txt:17
#, fuzzy
msgid "We will now explain each line of the example."
msgstr "现在，我们将解释示例的每一行。"

#: ../../source/introduction.txt:22
#, fuzzy
msgid ""
"In the beginning, we have to import the Gtk module to be able to access GTK"
"+'s classes and functions. Since a user's system can have multiple versions "
"of GTK+ installed at the same, we want to make sure that when we import Gtk "
"that it refers to GTK+ 3 and not any other version of the library, which is "
"the purpose of the statement ``gi.require_version('Gtk', '3.0')``."
msgstr ""
"在开始时，我们必须导入 Gtk 模块才能访问 GTK® 的类和功能。由于用户的系统可以同"
"时安装多个版本的 GTK+，因此我们希望确保当我们导入 GTK 时，它指的是 GTK+ 3，而"
"不是库的任何其他版本，这是语句'gi."
"require_version（'Gtk'，'3.0'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''"

#: ../../source/introduction.txt:29
msgid "The next line creates an empty window."
msgstr "下一行创建一个空窗口。"

#: ../../source/introduction.txt:34
msgid ""
"Followed by connecting to the window's delete event to ensure that the "
"application is terminated if we click on the *x* to close the window."
msgstr ""
"然后连接到窗口的删除事件，以确保如果我们单击 *x* 关闭窗口，应用程序将终止。"

#: ../../source/introduction.txt:40
msgid "In the next step we display the window."
msgstr "下一步，我们显示窗口。"

#: ../../source/introduction.txt:45
msgid ""
"Finally, we start the GTK+ processing loop which we quit when the window is "
"closed (see line 6)."
msgstr ""
"最后，我们启动 GTK+ 处理循环，当窗口关闭时，我们退出该循环（参见第 6 行）。"

#: ../../source/introduction.txt:51
msgid ""
"To run the program, open a terminal, change to the directory of the file, "
"and enter::"
msgstr "若要运行程序，请打开终端，更改为文件目录，然后输入："

#: ../../source/introduction.txt:57
msgid "Extended Example"
msgstr "扩展示例"

#: ../../source/introduction.txt:58
msgid ""
"For something a little more useful, here's the PyGObject version of the "
"classic \"Hello World\" program."
msgstr "对于更有用的东西，这里是经典的 \"你好世界\" 程序的 PyGObject 版本。"

#: ../../source/introduction.txt:66
#, fuzzy
msgid ""
"This example differs from the simple example as we sub-class :class:`Gtk."
"Window` to define our own :class:`MyWindow` class."
msgstr ""
"此示例不同于简单示例，因为我们子类 ：class：'Gtk.Window' 来定义我们自己的 ："
"class：'MyWindow' 类。"

#: ../../source/introduction.txt:72
#, fuzzy
msgid ""
"In the class's constructor we have to call the constructor of the super "
"class. In addition, we tell it to set the value of the property `title` to "
"`Hello World`."
msgstr ""
"在类的构造函数中，我们必须调用超级类的构造函数。此外，我们告诉它设置的财产"
"\"标题\"的价值为\"你好世界\"。"

#: ../../source/introduction.txt:78
#, fuzzy
msgid ""
"The next three lines are used to create a button widget, connect to its "
"`clicked` signal and add it as child to the top-level window."
msgstr ""
"接下来的三行用于创建一个按钮小部件，连接到其\"点击\"信号，并将其作为子级添加"
"到顶级窗口。"

#: ../../source/introduction.txt:84
#, fuzzy
msgid ""
"Accordingly, the method :meth:`on_button_clicked` will be called if you "
"click on the button."
msgstr ""
"因此，如果您单击按钮，on_button_clicked：'on_button_clicked'将调用方法："
"meth：'on_button_clicked'。"

#: ../../source/introduction.txt:89
#, fuzzy
msgid ""
"The last block, outside of the class, is very similar to the simple example "
"above, but instead of creating an instance of the generic :class:`Gtk."
"Window` class, we create an instance of :class:`MyWindow`."
msgstr ""
"最后一个块（类外部）与上面的简单示例非常相似，但我们创建一个 ："
"class：'MyWindow'的实例，而不是创建一个实例：class：'MyWindow'。"

#: ../../source/objects.txt:4
msgid "Objects"
msgstr "对象"

#: ../../source/objects.txt:6
#, fuzzy
msgid ""
"GObject is the fundamental type providing the common attributes and methods "
"for all object types in GTK+, Pango and other libraries based on GObject. "
"The :class:`GObject.GObject` class provides methods for object construction "
"and destruction, property access methods, and signal support."
msgstr ""
"GObject 是基本类型，为基于 GObject 的 GTK®、Pango 和其他库中的所有对象类型提"
"供通用属性和方法。：class：'GObject.GObject' 类提供对象构造和销毁、属性访问方"
"法和信号支持的方法。"

#: ../../source/objects.txt:11
#, fuzzy
msgid ""
"This section will introduce some important aspects about the GObject "
"implementation in Python."
msgstr "本节将介绍 Python 中的 GObject 实现方面的一些重要方面。"

#: ../../source/objects.txt:15
msgid "Inherit from GObject.GObject"
msgstr "继承自 GObject. GObject"

#: ../../source/objects.txt:17
#, fuzzy
msgid ""
"A native GObject is accessible via :class:`GObject.GObject`. It is rarely "
"instantiated directly, we generally use inherited class. A :class:`Gtk."
"Widget` is an inherited class of a :class:`GObject.GObject`. It may be "
"interesting to make an inherited class to create a new widget, like a "
"settings dialog."
msgstr ""
"本机 GObject 可通过 ：class 访问：'GObject.GObject'。它很少直接实例化，我们通"
"常使用继承类。 a：class：'Gtk.Widget' 是 ：class：'GObject.GObject'的继承类。"
"制作继承类以创建新小部件（如设置对话框）可能很有趣。"

#: ../../source/objects.txt:22
#, fuzzy
msgid ""
"To inherit from :class:`GObject.GObject`, you must call :meth:`GObject."
"GObject.__init__` in your constructor (if the class inherits from :class:"
"`Gtk.Button`, it must call :func:`Gtk.Button.__init__` for instance), like "
"in the example below:"
msgstr ""
"若要从 ：class：'GObject.GObject'继承，您必须在构造函数中调用 ："
"meth：'GObject.GObject.__init__'（如果类从 ：class：'Gtk.Button'继承，它必须"
"调用：func：'Gtk.Button.__init__'，例如，如下例所示："

#: ../../source/objects.txt:37
msgid "Signals"
msgstr "信号"

#: ../../source/objects.txt:39
#, fuzzy
msgid ""
"Signals connect arbitrary application-specific events with any number of "
"listeners. For example, in GTK+, every user event (keystroke or mouse move) "
"is received from the X server and generates a GTK+ event under the form of a "
"signal emission on a given object instance."
msgstr ""
"信号将任意应用程序特定的事件与任意数量的侦听器连接。例如，在 GTK® 中，从 X 服"
"务器接收每个用户事件（击键或鼠标移动），并在给定对象实例上以信号发射的形式生"
"成 GTK+ 事件。"

#: ../../source/objects.txt:44
#, fuzzy
msgid ""
"Each signal is registered in the type system together with the type on which "
"it can be emitted: users of the type are said to connect to the signal on a "
"given type instance when they register a function to be invoked upon the "
"signal emission. Users can also emit the signal by themselves or stop the "
"emission of the signal from within one of the functions connected to the "
"signal."
msgstr ""
"每个信号都注册在类型系统中，以及可以发出信号的类型：当该类型的用户注册一个在"
"信号发射时调用的函数时，据说该类型的用户将连接到给定类型实例上的信号。用户还"
"可以自己发出信号，或停止信号从连接到信号的功能之一内发射信号。"

#: ../../source/objects.txt:51
msgid "Receive signals"
msgstr "接收信号"

#: ../../source/objects.txt:53
msgid "See :ref:`signals`"
msgstr "参见 ：ref：`信号`"

#: ../../source/objects.txt:56
msgid "Create new signals"
msgstr "创建新信号"

#: ../../source/objects.txt:58
#, fuzzy
msgid ""
"New signals can be created by adding them to :attr:`GObject.GObject."
"__gsignals__`, a dictionary:"
msgstr "通过将新信号添加到 ：attr：'GObject.GObject.__gsignals__'，字典："

#: ../../source/objects.txt:61
#, fuzzy
msgid ""
"When a new signal is created, a method handler can also be defined, it will "
"be called each time the signal is emitted. It is called do_signal_name."
msgstr ""
"创建新信号时，还可以定义方法处理程序，每次发出信号时都会调用它。它被称为"
"do_signal_name。"

#: ../../source/objects.txt:75
#, fuzzy
msgid ""
":const:`GObject.SIGNAL_RUN_FIRST` indicates that this signal will invoke the "
"object method handler (:meth:`do_my_signal` here) in the first emission "
"stage. Alternatives are :const:`GObject.SIGNAL_RUN_LAST` (the method handler "
"will be invoked in the third emission stage) and :const:`GObject."
"SIGNAL_RUN_CLEANUP` (invoke the method handler in the last emission stage)."
msgstr ""
"：const：'GObject.SIGNAL_RUN_FIRST'表示此信号将调用对象方法处理程序（："
"meth：'do_my_signal''这里） 在第一个发射阶段。替代方案为 ：const：'GObject."
"SIGNAL_RUN_LAST\"（方法处理程序将在第三个发射阶段调用）和 ：const：'GObject."
"SIGNAL_RUN_CLEANUP\"（调用最后一个发射阶段的方法处理程序）。"

#: ../../source/objects.txt:81
#, fuzzy
msgid ""
"The second part, ``None``, indicates the return type of the signal, usually "
"``None``."
msgstr "第二部分\"无\"表示信号的返回类型，通常为\"无\"。"

#: ../../source/objects.txt:84
#, fuzzy
msgid ""
"``(int,)`` indicates the signal arguments, here, the signal will only take "
"one argument, whose type is int. This argument type list must end with a "
"comma."
msgstr ""
"''（int，）' 表示信号参数，在这里，信号将只使用一个参数，其类型为 int。此参数"
"类型列表必须以逗号结束。"

#: ../../source/objects.txt:88
#, fuzzy
msgid "Signals can be emitted using :meth:`GObject.GObject.emit`:"
msgstr "信号可以使用 ：meth：'GObject.GObject.emit'发出："

#: ../../source/objects.txt:97
#, fuzzy
msgid ""
"One of GObject's nice features is its generic get/set mechanism for object "
"properties. Each class inherited from :class:`GObject.GObject` can define "
"new properties. Each property has a type which never changes (e.g. str, "
"float, int...). For instance, they are used for :class:`Gtk.Button` where "
"there is a \"label\" property which contains the text of the button."
msgstr ""
"GObject 的一个很好的功能是其对象属性的通用获取/设置机制。从 ：class 继承的每"
"个类：'GObject.GObject'都可以定义新属性。每个属性都有一个永不更改的类型（例"
"如 str、float、int...）。例如，它们用于 ：class：'Gtk.button'，其中有一个包含"
"按钮文本的\"标签\"属性。"

#: ../../source/objects.txt:104
msgid "Use existing properties"
msgstr "使用现有属性"

#: ../../source/objects.txt:106
#, fuzzy
msgid ""
"The class :class:`GObject.GObject` provides several useful functions to "
"manage existing properties, :func:`GObject.GObject.get_property` and :func:"
"`GObject.GObject.set_property`."
msgstr ""
"类 ：'GObject.GObject' 提供了几个有用的函数来管理现有属性，：func：'GObject."
"GObject.get_property' 和 ：func：'GObject.GObject.set_property'。"

#: ../../source/objects.txt:109
#, fuzzy
msgid ""
"Some properties also have functions dedicated to them, called getter and "
"setter. For the property \"label\" of a button, there are two functions to "
"get and set them, :func:`Gtk.Button.get_label` and :func:`Gtk.Button."
"set_label`."
msgstr ""
"某些属性还具有专用于它们的功能，称为 getter 和 setter。对于按钮的属性\"标签"
"\"，有两个函数要获取和设置它们，：func：'Gtk.Button.get_label'和 ："
"func：'Gtk.Button.set_label'。"

#: ../../source/objects.txt:114
msgid "Create new properties"
msgstr "创建新属性"

#: ../../source/objects.txt:116
#, fuzzy
msgid ""
"A property is defined with a name and a type. Even if Python itself is "
"dynamically typed, you can't change the type of a property once it is "
"defined. A property can be created using :class:`GObject.Property`."
msgstr ""
"使用名称和类型定义属性。即使 Python 本身是动态键入的，在定义属性后也无法更改"
"该属性的类型。可以使用 ：class 创建属性：'GObject.property'。"

#: ../../source/objects.txt:131
#, fuzzy
msgid ""
"Properties can also be read-only, if you want some properties to be readable "
"but not writable. To do so, you can add some flags to the property "
"definition, to control read/write access. Flags are :const:`GObject."
"ParamFlags.READABLE` (only read access for external code), :const:`GObject."
"ParamFlags.WRITABLE` (only write access), :const:`GObject.ParamFlags."
"READWRITE` (public):"
msgstr ""
"如果希望某些属性是可读但不可写，则属性也可以是只读的。为此，可以向属性定义添"
"加一些标志，以控制读/写访问。标志是 ：const：'GObject.paramFlags.可读'（仅读"
"取外部代码），：：'GObject.paramFlags.Writable'（仅写入访问），：康斯"
"特：'GObject.paramflags.READWRITE'（公共）："

#: ../../source/objects.txt:146
#, fuzzy
msgid ""
"You can also define new read-only properties with a new method decorated "
"with :class:`GObject.Property`:"
msgstr ""
"还可以使用使用 ：class 装饰的新方法定义新的只读属性：'GObject.property'："

#: ../../source/objects.txt:162
msgid "You can get this property using:"
msgstr "您可以使用："

#: ../../source/objects.txt:170
#, fuzzy
msgid ""
"The API of :class:`GObject.Property` is similar to the builtin :py:func:"
"`property`. You can create property setter in a way similar to Python "
"property:"
msgstr ""
"：class 的 API：'GObject.属性' 类似于内置的 :p y：func：'属性'。可以以类似于 "
"Python 属性的方式创建属性设置器："

#: ../../source/objects.txt:191
#, fuzzy
msgid ""
"There is also a way to define minimum and maximum values for numbers, using "
"a more verbose form:"
msgstr "还有一种方法，使用更冗长的窗体来定义数字的最小值和最大值："

#: ../../source/objects.txt:227
#, fuzzy
msgid ""
"Properties must be defined in :attr:`GObject.GObject.__gproperties__`, a "
"dictionary, and handled in do_get_property and do_set_property."
msgstr ""
"属性必须在 ：attr：'GObject.GObject.__gproperties__'中定义，字典，并在"
"do_get_property中do_set_property。"

#: ../../source/objects.txt:231
msgid "Watch properties"
msgstr "监视属性"

#: ../../source/objects.txt:233
#, fuzzy
msgid ""
"When a property is modified, a signal is emitted, whose name is \"notify::"
"property-name\":"
msgstr "修改属性时，将发出信号，其名称为\"通知：:p属性名称\"："

#: ../../source/objects.txt:248
#, fuzzy
msgid ""
"Note that you have to use the canonical property name when connecting to the "
"notify signals, as explained in :func:`GObject.Object.signals.notify`. For "
"instance, for a Python property `foo_bar_baz` you would connect to the "
"signal `notify::foo-bar-baz` using"
msgstr ""
"请注意，在连接到通知信号时必须使用规范属性名称，如 ：func：'GObject.Object."
"signals.notify\"中所述。例如，对于 Python 属性\"foo_bar_baz\"，您将使用"

#: ../../source/objects.txt:263
msgid "API"
msgstr "API"

#: ../../source/objects.txt:269
msgid "Retrieves a property value."
msgstr "检索属性值。"

#: ../../source/objects.txt:273
#, fuzzy
msgid "Set property *property_name* to *value*."
msgstr "将属性 *property_name* 设置为 *value*。"

#: ../../source/objects.txt:277
#, fuzzy
msgid ""
"Emit signal *signal_name*. Signal arguments must follow, e.g. if your signal "
"is of type ``(int,)``, it must be emitted with::"
msgstr ""
"发出信号 *signal_name*。信号参数必须遵循，例如，如果信号类型为'（int，）'，则"
"必须用以下信息发出："

#: ../../source/objects.txt:284
#, fuzzy
msgid ""
"This method freezes all the \"notify::\" signals (which are emitted when any "
"property is changed) until the :meth:`thaw_notify` method is called."
msgstr ""
"此方法冻结所有\"通知：\"信号（当任何属性更改时发出），直到调用 ："
"meth：'thaw_notify'方法。"

#: ../../source/objects.txt:288
#, fuzzy
msgid ""
"It recommended to use the *with* statement when calling :meth:"
"`freeze_notify`, that way it is ensured that :meth:`thaw_notify` is called "
"implicitly at the end of the block::"
msgstr ""
"建议在调用 ：meth：'freeze_notify'时使用 *with* 语句，这样可以确保："
"meth：'thaw_notify'在块的末尾隐式调用：："

#: ../../source/objects.txt:298
#, fuzzy
msgid ""
"Thaw all the \"notify::\" signals which were thawed by :meth:`freeze_notify`."
msgstr "解冻所有\"通知：\"由：meth：'freeze_notify\"解冻的信号。"

#: ../../source/objects.txt:300
#, fuzzy
msgid ""
"It is recommended to not call :meth:`thaw_notify` explicitly but use :meth:"
"`freeze_notify` together with the *with* statement."
msgstr ""
"建议不要明确调用 ：meth：'thaw_notify'，但使用 ：meth：freeze_notify\"与 *与 "
"* 语句。"

#: ../../source/objects.txt:305
#, fuzzy
msgid ""
"Blocks a handler of an instance so it will not be called during any signal "
"emissions unless :meth:`handler_unblock` is called for that *handler_id*. "
"Thus \"blocking\" a signal handler means to temporarily deactivate it, a "
"signal handler has to be unblocked exactly the same amount of times it has "
"been blocked before to become active again."
msgstr ""
"阻止实例的处理程序，以便在任何信号输出期间不会调用实例，除非 ："
"meth：'handler_unblock'为该 *handler_id* 。因此，\"阻止\"信号处理程序意味着暂"
"时停用它，信号处理程序必须解除阻止，与它之前被阻止的时间完全相同，才能再次处"
"于活动状态。"

#: ../../source/objects.txt:311
#, fuzzy
msgid ""
"It is recommended to use :meth:`handler_block` in conjunction with the "
"*with* statement which will call :meth:`handler_unblock` implicitly at the "
"end of the block::"
msgstr ""
"建议使用 ：meth：'handler_block'与 *with* 语句一起使用："
"meth：'handler_unblock'隐式在块的末尾：："

#: ../../source/objects.txt:321
#, fuzzy
msgid ""
"Undoes the effect of :meth:`handler_block`. A blocked handler is skipped "
"during signal emissions and will not be invoked until it has been unblocked "
"exactly the amount of times it has been blocked before."
msgstr ""
"撤消 ：meth：'handler_block'。在信号发出期间跳过阻塞的处理程序，在解除阻止之"
"前不会调用该处理程序，而该处理程序正是以前被阻止的量。"

#: ../../source/objects.txt:325
#, fuzzy
msgid ""
"It is recommended to not call :meth:`handler_unblock` explicitly but use :"
"meth:`handler_block` together with the *with* statement."
msgstr ""
"建议不要明确调用 ：meth：'handler_unblock'，但使用 ：meth：handler_block\"与 "
"*with* 语句一起。"

#: ../../source/objects.txt:330
#, fuzzy
msgid "A dictionary where inherited class can define new signals."
msgstr "继承类可以定义新信号的字典。"

#: ../../source/objects.txt:332
#, fuzzy
msgid ""
"Each element in the dictionary is a new signal. The key is the signal name. "
"The value is a tuple, with the form::"
msgstr ""
"字典中的每个元素都是一个新信号。关键是信号名称。该值是一个元组，其形式为："

#: ../../source/objects.txt:337
#, fuzzy
msgid ""
":const:`GObject.SIGNAL_RUN_FIRST` can be replaced with :const:`GObject."
"SIGNAL_RUN_LAST` or :const:`GObject.SIGNAL_RUN_CLEANUP`. ``None`` is the "
"return type of the signal. ``(int,)`` is the list of the parameters of the "
"signal, it must end with a comma."
msgstr ""
"：康斯特：GObject.SIGNAL_RUN_FIRST\"\"\"\"\"\"\"\"\"\"GObject.SIGNAL_RUN_LAST"
"\"或：康斯特：'GObject.SIGNAL_RUN_CLEANUP'。\"无\"是信号的返回类"
"型。''（int，）' 是信号参数的列表，它必须以逗号结束。"

#: ../../source/objects.txt:346
#, fuzzy
msgid ""
"The :attr:`__gproperties__` dictionary is a class property where you define "
"the properties of your object. This is not the recommend way to define new "
"properties, the method written above is much less verbose. The benefits of "
"this method is that a property can be defined with more settings, like the "
"minimum or the maximum for numbers."
msgstr ""
"：attr：'__gproperties__'字典是定义对象属性的类属性。这不是定义新属性的推荐方"
"法，上面写的方法要详细得多。此方法的好处是，可以使用更多设置（如数字的最小值"
"或最大值）定义属性。"

#: ../../source/objects.txt:352
msgid "The key is the name of the property"
msgstr "键是属性的名称"

#: ../../source/objects.txt:354
#, fuzzy
msgid ""
"The value is a tuple which describe the property. The number of elements of "
"this tuple depends on its first element but the tuple will always contain at "
"least the following items:"
msgstr ""
"该值是描述属性的元组。此元组的元素数取决于其第一个元素，但元组将始终至少包含"
"以下项："

#: ../../source/objects.txt:358
#, fuzzy
msgid "The first element is the property's type (e.g. ``int``, ``float``...)."
msgstr "第一个元素是属性的类型（例如\"int\"，\"float'\"...）。"

#: ../../source/objects.txt:360
#, fuzzy
msgid ""
"The second element is the property's nick name, which is a string with a "
"short description of the property. This is generally used by programs with "
"strong introspection capabilities, like the graphical user interface builder "
"`Glade`_."
msgstr ""
"第二个元素是属性的昵称，这是一个字符串，具有属性的简短描述。这通常由具有强大"
"反省功能的程序使用，例如图形用户界面生成器\"Glade\"_ 。"

#: ../../source/objects.txt:365
#, fuzzy
msgid ""
"The third one is the property's description or blurb, which is another "
"string with a longer description of the property. Also used by `Glade`_ and "
"similar programs."
msgstr ""
"第三个是属性的描述或模糊，这是另一个字符串，具有较长的属性描述。也用于\"Glade"
"\"_和类似的程序。"

#: ../../source/objects.txt:369
#, fuzzy
msgid ""
"The last one (which is not necessarily the forth one as we will see later) "
"is the property's flags: :const:`GObject.PARAM_READABLE`, :const:`GObject."
"PARAM_WRITABLE`, :const:`GObject.PARAM_READWRITE`."
msgstr ""
"最后一个（这不一定是我们稍后将看到的第四个）是属性的标志：：：康斯"
"特：'GObject.PARAM_READABLE'，：康斯特：'GObject.PARAM_WRITABLE'，：康斯"
"特：'GObject.PARAM_READWRITE'。"

#: ../../source/objects.txt:373
#, fuzzy
msgid ""
"The absolute length of the tuple depends on the property type (the first "
"element of the tuple). Thus we have the following situations:"
msgstr ""
"元组的绝对长度取决于属性类型（元组的第一个元素）。因此，我们有以下情况："

#: ../../source/objects.txt:376
#, fuzzy
msgid ""
"If the type is ``bool`` or ``str``, the forth element is the default value "
"of the property."
msgstr "如果类型为\"bool\"或\"str\"，则第四个元素是属性的默认值。"

#: ../../source/objects.txt:379
#, fuzzy
msgid ""
"If the type is ``int`` or ``float``, the forth element is the minimum "
"accepted value, the fifth element is the maximum accepted value and the "
"sixth element is the default value."
msgstr ""
"如果类型为\"int\"或\"float\"，则第四个元素是最小接受值，第五个元素是最大接受"
"值，第六个元素是默认值。"

#: ../../source/objects.txt:383
#, fuzzy
msgid "If the type is not one of these, there is no extra element."
msgstr "如果类型不是其中之一，则没有额外的元素。"

#: ../../source/objects.txt:388
#, fuzzy
msgid "Invoke the object method handler in the first emission stage."
msgstr "在第一个发射阶段调用对象方法处理程序。"

#: ../../source/objects.txt:392
#, fuzzy
msgid "Invoke the object method handler in the third emission stage."
msgstr "在第三个发射阶段调用对象方法处理程序。"

#: ../../source/objects.txt:396
#, fuzzy
msgid "Invoke the object method handler in the last emission stage."
msgstr "调用最后一个发射阶段的对象方法处理程序。"

#: ../../source/objects.txt:400
msgid "The property is readable."
msgstr "该属性是可读的。"

#: ../../source/objects.txt:404
msgid "The property is writable."
msgstr "该属性是可写的。"

#: ../../source/objects.txt:408
msgid "The property is readable and writable."
msgstr "该属性是可读和可写。"

#: ../../source/progressbar.txt:2
msgid "ProgressBar"
msgstr "进度条"

#: ../../source/progressbar.txt:4
#, fuzzy
msgid ""
"The :class:`Gtk.ProgressBar` is typically used to display the progress of a "
"long running operation. It provides a visual clue that processing is "
"underway. The :class:`Gtk.ProgressBar` can be used in two different modes: "
"*percentage mode* and *activity mode*."
msgstr ""
"：class：'Gtk.ProgressBar' 通常用于显示长时间运行操作的进度。它提供了处理正在"
"进行中的视觉线索。：class：'Gtk.ProgressBar' 可用于两种不同的模式：*百分比模"
"式* 和 *活动模式*。"

#: ../../source/progressbar.txt:9
#, fuzzy
msgid ""
"When an application can determine how much work needs to take place (e.g. "
"read a fixed number of bytes from a file) and can monitor its progress, it "
"can use the :class:`Gtk.ProgressBar` in *percentage mode* and the user sees "
"a growing bar indicating the percentage of the work that has been completed. "
"In this mode, the application is required to call :meth:`Gtk.ProgressBar."
"set_fraction` periodically to update the progress bar, passing a float "
"between 0 and 1 to provide the new percentage value."
msgstr ""
"当应用程序可以确定需要执行多少工作（例如，从文件中读取固定数量的字节）并监视"
"其进度时，它可以使用 *百分比模式下的 ：class：'Gtk.ProgressBar'，并且用户看到"
"一个显示已完成工作的百分比的不断增长的栏。在此模式下，应用程序需要调用："
"meth：'Gtk.ProgressBar.set_fraction'定期更新进度条，传递介于 0 和 1 之间的浮"
"点以提供新的百分比值。"

#: ../../source/progressbar.txt:17
#, fuzzy
msgid ""
"When an application has no accurate way of knowing the amount of work to do, "
"it can use *activity mode*, which shows activity by a block moving back and "
"forth within the progress area. In this mode, the application is required to "
"call :meth:`Gtk.ProgressBar.pulse` periodically to update the progress bar. "
"You can also choose the step size, with the :meth:`Gtk.ProgressBar."
"set_pulse_step` method."
msgstr ""
"当应用程序无法准确知道要完成的工作量时，它可以使用 *活动模式*，该模式通过块在"
"进度区域中来回移动显示活动。在此模式下，应用程序需要定期调用：meth：'Gtk."
"ProgressBar.pulse'来更新进度条。您也可以选择步进大小，使用 ：meth：'Gtk."
"ProgressBar.set_pulse_step'方法。"

#: ../../source/progressbar.txt:24
#, fuzzy
msgid ""
"By default, :class:`Gtk.ProgressBar` is horizontal and left-to-right, but "
"you can change it to a vertical progress bar by using the :meth:`Gtk."
"ProgressBar.set_orientation` method. Changing the direction the progress bar "
"grows can be done using :meth:`Gtk.ProgressBar.set_inverted`. :class:`Gtk."
"ProgressBar` can also contain text which can be set by calling :meth:`Gtk."
"ProgressBar.set_text` and :meth:`Gtk.ProgressBar.set_show_text`."
msgstr ""
"默认情况下，：类：'Gtk.ProgressBar' 是水平和从左到右，但您可以使用："
"meth：'Gtk.ProgressBar.set_orientation\"方法将它更改为垂直进度条。改变进度条"
"增长的方向可以使用：meth：'Gtk.ProgressBar.set_inverted\"。：类：'Gtk."
"ProgressBar'也可以包含文本，可以通过调用：meth：'Gtk.ProgressBar."
"set_text'和：meth：'Gtk.ProgressBar.set_show_text\"来设置。"
